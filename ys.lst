                        ; -------------------------------------------------------------------
                        ; -------------------------------------------------------------------
                        ; *** ys: send one or more files using YMODEM batch protocol
                        ; ***
                        ; *** Build #
                        ; ***  1: Proof of concept version
                        ; ***  2: First bug squashed: 256 & 512 byte files were sent 
                        ; ***     as 0 bytes
                        ; ***  3: Added file timestamp to block 0
                        ; ***  4: Inlined some Tx/Rx code to make it fast enough to
                        ; ***     catch the ACK & CRC/NAK at the end of a block send
                        ; ***  5: Dec/hex oops in "Couldn't open file:" message
                        ; ***  6: missed a "pop rc" when O_READ didn't read any bytes
                        ; ***  7: moved endrom to end of uninitialised data so that
                        ; ***     Elf/OS 0.4.x can tell if we're colliding with the heap.
                        ; ***     Make stack manipulation interrupt safe on entry and
                        ; ***     exit (even though soft UART code is unlikely to work
                        ; ***     if interrupted).
                        ; ***  8: Add UART type detection & auto config. Both hard &
                        ; ***     soft UARTs supported.
                        ; ***  9: Expand directory files on cmd line into their component
                        ; ***     data files for sending (NOT recursive)
                        ; *******************************************************************
                        ; *** This software is released to the public domain.		  ***
                        ; *** You have permission to use, modify, copy, and distribute	  ***
                        ; *** this software as you please.				  ***
                        ; *******************************************************************
                        ;
                        ; Register usage:
                        ;
                        ; System:
                        ;   r0   - Resesrved for DMA
                        ;   r1   - Reserved for interrupts
                        ;   r2   - Stack pointer
                        ;   r3   - Program counter
                        ;   r4   - SCALL program counter
                        ;   r5   - SRET program counter
                        ;   r6   - SCALL return address
                        ;   re.0 - SCALL overwrites with D
                        ;   re.1 - Baud rate constant
                        ;
                        ; Main program :
                        ;
                        ;   ra   - Command line pointer (on exec)
                        ;
                        ; All other registers are available for subroutines.
                        ;
                        	include	"bios.inc"
                        ; *******************************************************************
                        ; *** This software is copyright 2006 by Michael H Riley		***
                        ; *** You have permission to use, modify, copy, and distribute	***
                        ; *** this software so long as this copyright notice is retained. ***
                        ; *** This software may not be used in commercial applications	***
                        ; *** without express written permission from the author.	 ***
                        ; *******************************************************************
                        
                        ; f_getdev bit values
                        
                        b_devIDE	equ	00000001b	; IDE
                        b_devFLPY	equ	00000010b	; floppy
                        b_devBBSER	equ	00000100b	; Bit-banged serial
                        b_devUART	equ	00001000b	; UART
                        b_devRTC	equ	00010000b	; RTC
                        b_devNVR	equ	00100000b	; NVRAM
                        b_devNBREAD	equ	00000001b	; NBREAD supported
                        
                        #ifndef _IS_BIOS
                        
                        ; Define address for standard BIOS vectors
                        BIOS	equ	0ff00h
                        
                        ; Define address for extended BIOS vectors
                        EBIOS	equ	0f800h
                        
                        scall	equ	r4			; register for SCALL
                        sret	equ	r5			; register for SRET
                        
                        f_boot		equ	(BIOS+00h)	; boot from ide device
                        f_type		equ	(BIOS+03h)	; type 1 character to console
                        f_read		equ	(BIOS+06h)	; read 1 character from console
                        f_msg		equ	(BIOS+09h)	; type asciiz string to console
                        f_typex		equ	(BIOS+0ch)	; depricated, just returns now
                        f_input		equ	(BIOS+0fh)	; read asciiz from console
                        f_strcmp	equ	(BIOS+12h)	; compare 2 strings
                        f_ltrim		equ	(BIOS+15h)	; trim leading spaces
                        f_strcpy	equ	(BIOS+18h)	; copy an asciiz string
                        f_memcpy	equ	(BIOS+1bh)	; copy memory
                        f_wrtsec	equ	(BIOS+1eh)	; write floppy sector (depricated)
                        f_rdsec		equ	(BIOS+21h)	; read floppy sector (depricated)
                        f_seek0		equ	(BIOS+24h)	; floppy seek to track 0 (depricated)
                        f_seek		equ	(BIOS+27h)	; floopy track seek (depricated)
                        f_drive		equ	(BIOS+2ah)	; select floppy drive (depricated)
                        f_setbd		equ	(BIOS+2dh)	; set console baud rate
                        f_mul16		equ	(BIOS+30h)	; 16-bit multiply
                        f_div16		equ	(BIOS+33h)	; 16-bit division
                        f_idereset	equ	(BIOS+36h)	; reset ide device
                        f_idewrite	equ	(BIOS+39h)	; write ide sector
                        f_ideread	equ	(BIOS+3ch)	; read ide sector
                        f_initcall	equ	(BIOS+3fh)	; initialize R4 and R5
                        f_bootide	equ	(BIOS+42h)	; boot from ide device
                        f_hexin		equ	(BIOS+45h)	; convert ascii number to hex
                        f_hexout2	equ	(BIOS+48h)	; convert hex to 2-digit ascii
                        f_hexout4	equ	(BIOS+4bh)	; convert hex to 4-digit ascii
                        f_tty		equ	(BIOS+4eh)	; type character to console
                        f_mover		equ	(BIOS+51h)	; program relocator
                        f_minimon	equ	(BIOS+54h)	; mini monitor
                        f_freemem	equ	(BIOS+57h)	; determine memory size
                        f_isnum		equ	(BIOS+5ah)	; determine if D is numeric
                        f_atoi		equ	(BIOS+5dh)	; convert ascii to integer
                        f_uintout	equ	(BIOS+60h)	; convert unsigned integer to ascii
                        f_intout	equ	(BIOS+63h)	; convert signed integer to ascii
                        f_inmsg		equ	(BIOS+66h)	; type in-line message
                        f_inputl	equ	(BIOS+69h)	; read limited line from console
                        f_brktest	equ	(BIOS+6ch)	; check for serial break
                        f_findtkn	equ	(BIOS+6fh)	; find token in a token table
                        f_isalpha	equ	(BIOS+72h)	; determine if D is alphabetic
                        f_ishex		equ	(BIOS+75h)	; determine if D is hexadecimal
                        f_isalnum	equ	(BIOS+78h)	; determine if D is alpha or numeric
                        f_idnum		equ	(BIOS+7bh)	; determine type of ascii number
                        f_isterm	equ	(BIOS+7eh)	; determine if D is a termination char
                        f_getdev	equ	(BIOS+81h)	; get supported devices
                        f_nbread	equ	(BIOS+84);	; read 1 char from console (non blocking)
                        
                        f_version	equ	(BIOS+0f9h)	; 3 bytes holding bios version number
                        
                        ; "Extended" BIOS vectors
                        
                        f_bread		equ	(EBIOS+00h)	; read from onboard serial port
                        f_btype		equ	(EBIOS+03h)	; write to onboard serial port
                        f_btest		equ	(EBIOS+06h)	; test onboard serial port
                        f_utype		equ	(EBIOS+09h)	; write to disk board UART
                        f_uread		equ	(EBIOS+0ch)	; read from disk board UART
                        f_utest		equ	(EBIOS+0fh)	; test disk board UART
                        f_usetbd	equ	(EBIOS+12h)	; set disk board UART baud rate and format
                        f_gettod	equ	(EBIOS+15h)	; read time of day clock
                        f_settod	equ	(EBIOS+18h)	; set time of day clock
                        f_rdnvr		equ	(EBIOS+1bh)	; read non volatile RAM
                        f_wrnvr		equ	(EBIOS+1eh)	; write non volatile RAM
                        f_idesize	equ	(EBIOS+21h)	; return size of attached IDE drive(s)
                        f_ideid		equ	(EBIOS+24h)	; return device data for IDE drive(s)
                        f_tmtoas	equ	(EBIOS+2ah)	; time to ASCII string
                        f_dttoas	equ	(EBIOS+27h)	; date to ASCII string
                        f_rtctest	equ	(EBIOS+2dh)	; test size and presence of RTC/NVR
                        f_astodt	equ	(EBIOS+30h)	; convert ASCII string to date
                        f_astotm	equ	(EBIOS+33h)	; convert ASCII string to time
                        f_nvrcchk	equ	(EBIOS+36h)	; compute NVR checksum
                        
                        #endif
                        
                        	include	"kernel.inc"
                        O_CREAT	equ	00000001b
                        O_TRUNC	equ	00000010b
                        O_APPND	equ	00000100b
                        ;
                        errexists	   equ	1
                        errnoffnd	   equ	2
                        errinvdir	   equ	3
                        errisdir	      equ	4
                        errdirnotempty	equ	5
                        errnotexec	   equ	6
                        ;
                        ff_dir		   equ	00000001b
                        ff_exec		   equ	00000010b
                        ff_write	      equ	00000100b
                        ff_hide		   equ	00001000b
                        ff_archive	   equ	00010000b
                        
                        #ifndef _IS_KERNEL
                        
                        O_CLDBOOT: equ     0300h               ; jump to cold boot routine
                        O_WRMBOOT: equ     0303h               ; jump to warm boot routine
                        O_OPEN:    equ     0306h               ; open a file
                        O_READ:    equ     0309h               ; read from file
                        O_WRITE:   equ     030ch               ; write to file
                        O_SEEK:    equ     030fh               ; seek to file position
                        O_CLOSE:   equ     0312h               ; close file
                        O_OPENDIR: equ     0315h               ; open dir as a file
                        O_DELETE:  equ     0318h               ; delete a file
                        O_RENAME:  equ     031bh               ; rename a file
                        O_EXEC:    equ     031eh               ; execute an external program
                        O_MKDIR:   equ     0321h               ; make directory
                        O_CHDIR:   equ     0324h               ; change directory
                        O_RMDIR:   equ     0327h               ; remove directory
                        O_RDLUMP:  equ     032Ah               ; read LAT entry
                        O_WRLUMP:  equ     032Dh               ; write LAT entry
                        O_TYPE:    equ     0330h               ; passthrough for console output
                        O_MSG:     equ     0333h               ; passthrough for console output
                        O_READKEY: equ     0336h               ; passthrough for console input
                        O_INPUT:   equ     0339h               ; passthrough for console input
                        O_PRTSTAT: equ     033ch               ; printer status
                        O_PRINT:   equ     033fh               ; output to printer
                        O_EXECBIN: equ     0342h               ; execute from default directory
                        O_SETDEF:  equ     0345h               ; set/get default directory
                        O_KINIT:   equ     0348h               ; reserved - do not use!!!
                        O_INMSG:   equ     034bh               ; passthrough for console output
                        O_GETDEV:  equ     034eh               ; passthrough to f_getdef
                        O_GETTOD:  equ     0351h               ; passthrough to f_gettod
                        O_SETTOD:  equ     0354h               ; passthrough to f_settod
                        O_INPUTL:  equ     0357h               ; passthrough to f_inputl
                        O_BOOT:    equ     035ah               ; passthrough to f_boot
                        O_SETBD:   equ     0360h               ; passthrough to f_setbd
                        O_INITCALL: equ    0363h               ; passthrough to f_initcall
                        O_BRKTEST: equ     0366h               ; passthrough to f_brktest
                        O_DEVCTRL: equ     0369h               ; Hook for device control drivers
                        O_ALLOC:   equ     036ch               ; passthrough to alloc
                        O_DEALLOC: equ     036fh               ; passthrough to dealloc
                        O_TERMCTRL: equ    0372h               ; Hook for terminal control drivers
                        O_MEMCTRL: equ     0375h               ; Hook for memory control drivers
                        I_SERVE:   equ     03f6h               ; address of interrupt chain head
                        V_IVEC:    equ     03fdh               ; interrupt head
                        V_DVEC:    equ     036ah               ; device head
                        K_VER:     equ     0400h               ; kernel version number
                        K_BUILD:   equ     0403h               ; kernel build number
                        K_BMONTH:  equ     0405h               ; kernel build month
                        K_BDAY:    equ     0406h               ; kernel build day
                        K_BYEAR:   equ     0407h               ; kernel build month
                        K_HIMEM:   equ     0442h               ; high memory pointer
                        K_LOWMEM:  equ     0465h               ; lowest memory heap can use
                        K_RETVAL:  equ     0467h               ; D on program exit
                        K_HEAP:    equ     0468h               ; heap pointer
                        K_CLKFREQ: equ     0470h               ; system clock frequency
                        K_MONTH:   equ     0475h               ; date/time
                        K_DAY:     equ     0476h
                        K_YEAR:    equ     0477h
                        K_HOUR:    equ     0478h
                        K_MINUTE:  equ     0479h
                        K_SECOND:  equ     047ah
                        K_SECDEN:  equ     047bh
                        K_SECNUM:  equ     047dh
                        ;
                        ;O_HIMEM:   equ     0442h               ; himem value
                        O_DATTIM:  equ     0475h               ; date/time block
                        ;
                        #endif
                        
                        ;	
                        debug	equ	0
                        info	equ	0
                        ;
                        ; ***************************************************
                        ; ***** Constants				*****
                        ; ***************************************************
                        cr	equ	'M'-'@'
                        lf	equ	'J'-'@'
                        bs	equ	'H'-'@'
                        ;
                        soh	equ	'A'-'@'		; 128 byte packet header
                        stx	equ	'B'-'@'		; 1K byte packet header
                        eot	equ	'D'-'@'		; end of file transfer marker
                        ack	equ	'F'-'@'		; Acknowledge (good packet)
                        nak	equ	'U'-'@'		; Negative acknowledge (bad packet)
                        can	equ	'X'-'@'		; cancel transfer
                        crc	equ	'C'		; use CRC rather than checksum
                        ;
                        ; ***************************************************
                        ; ***** This block is the Execution header for	*****
                        ; ***** a stand-alone program. It begins 6	*****
                        ; *****bytes before the program start.		*****
                        ; ***************************************************
                        LoadAdr	equ	2000h
                        	org	LoadAdr-6	; Header starts at 01ffah
   1ffa   20 00         	dw	LoadAdr
   1ffc   19 3e         	dw	EndRom-LoadAdr
   1ffe   20 00         	dw	LoadAdr
                        ;
                        ; ***************************************************
                        ; ***** Code start				*****
                        ; ***************************************************
   2000   30 52         	br	Start
                        ;
                        ; ***************************************************
                        ; ***** Program header				*****
                        ; ***************************************************
   2002   88 03 07 e5   	date
   2006   00 09         Build:	dw	9		; build number
   2008   65 78 70 61   	db	'expand dirs in cmd tail',0
   200c   6e 64 20 64   
   2010   69 72 73 20   
   2014   69 6e 20 63   
   2018   6d 64 20 74   
   201c   61 69 6c 00   
                        ;
                        monthDays:
   2020   1f 1c 1f 1e   	db	31,28,31,30,31,30,31,31,30,31,30,31
   2024   1f 1e 1f 1f   
   2028   1e 1f 1e 1f   
                        ;
                        CmdFilDes:
   202c   00 00 00 00   	db	0,0,0,0		; current file offset
   2030   2d 00         	dw	CmdDta		; DTA
   2032   00 00         	dw	0		; eof
   2034   00            	db	0		; flags
                        CmdDirSec:
   2035   00 00 00 00   	db	0,0,0,0		; dir sector
                        CmdDirOfs:
   2039   00 00         	dw	0		; dir offset
   203b   00 00 00 00   	db	0,0,0,0		; current sector in DTA
                        ;
                        SndFilDes:
   203f   00 00 00 00   	db	0,0,0,0		; current file offset
   2043   2f 00         	dw	SndDta		; DTA
   2045   00 00         	dw	0		; eof
   2047   00            	db	0		; flags
                        SndDirSec:
   2048   00 00 00 00   	db	0,0,0,0		; dir sector
                        SndDirOfs:
   204c   00 00         	dw	0		; dir offset
   204e   00 00 00 00   	db	0,0,0,0		; current sector in DTA
                        ;
                        ; ***************************************************
                        ; ***** Main program				*****
                        ; ***************************************************
                        start:	
   2052   86 73 96 73   	push	r6		; save Elf/OS's return address on its stack
   2056   f8 01         	ldi     1		; assume interrupts are enabled
   2058   cc            	lsie			; skip if they are
   2059   f8 00         	ldi	0		; mark interrupts disabled
   205b   ae            	plo	re		; save IE flag
   205c   f8 23         	ldi	023h		; setup for DIS (X=2, P=3)
   205e   52            	str	r2
   205f   71            	dis			; disable interrupts
   2060   22            	dec	r2
   2061   f8 31 bf f8   	load	rf,saveStack	; save Elf/OS's stack
   2065   8c af         
   2067   92            	ghi	r2
   2068   5f            	str	rf
   2069   1f            	inc	rf
   206a   82            	glo	r2
   206b   5f            	str	rf
   206c   f8 31 b2 f8   	load	r2,localStack	; use our own stack
   2070   8b a2         
   2072   8e            	glo	re		; recover IE flag
   2073   c2 20 7b      	lbz	start2		; jump if interrupts were disabled
   2076   f8 23         	ldi	023h		; setup for RET (X=2, P=3)
   2078   52            	str	r2
   2079   70            	ret			; re-enable interrupts
   207a   22            	dec	r2
                        start2:
   207b   9e            	ghi	re		; turn off console echo
   207c   fa fe         	ani	11111110b
   207e   be            	phi	re
   207f   d4 28 82      	call	UARTsetup	; auto detect/config UART
                        ;
   2082   d4 20 f4      	call	NextFileName	; point to first file name
   2085   ca 20 b1      	lbnz	NextFile	; and go send it
   2088   d4 03 4b      	call	O_INMSG		; otherwise display usage message
   208b   55 73 61 67   	db	'Usage:	ys filename [filename...]',cr,lf,0
   208f   65 3a 09 79   
   2093   73 20 66 69   
   2097   6c 65 6e 61   
   209b   6d 65 20 5b   
   209f   66 69 6c 65   
   20a3   6e 61 6d 65   
   20a7   2e 2e 2e 5d   
   20ab   0d 0a 00      
   20ae   c0 20 fd      	lbr	Exit		; and return to os
                        NextFile:
   20b1   d4 21 25      	call	ProcFile	; process next file (either send or expand)
   20b4   d4 20 f4      	call	NextFileName	; point to next file name in cmd tail
   20b7   ca 20 b1      	lbnz	NextFile	; loop for next file
   20ba   d4 25 c3      	call	WaitNAKorCRC
   20bd   f8 34 bf f8   	load	rf,blknum
   20c1   b8 af         
   20c3   f8 00         	ldi	0
   20c5   5f            	str	rf
   20c6   d4 25 8e      	call	ZeroBlock0	; send zero filled block 0 to finish up
                        	 if	debug=0
   20c9   f8 27 bf f8   	load	rf,SoftAckedAction
   20cd   44 af         
   20cf   f8 81         	ldi	low nextBlock
   20d1   5f            	str	rf
   20d2   f8 26 bf f8   	load	rf,HardAckedAction
   20d6   83 af         
   20d8   f8 27         	ldi	high nextBlock
   20da   5f            	str	rf
   20db   1f            	inc	rf
   20dc   f8 81         	ldi	low nextBlock
   20de   5f            	str	rf
                        	 endi
   20df   f8 34 bf f8   	load	rf,block0
   20e3   be af         
   20e5   f8 00 bc f8   	load	rc,128
   20e9   80 ac         
   20eb   f8 0a         	ldi	10
   20ed   a8            	plo	r8
   20ee   d4 26 09      	call	SendBlock
   20f1   c0 20 fd      	lbr	Exit		; and return to os
                        ;
                        ; ***************************************************
                        ; ***** NextFilename: advance RA to the next	*****
                        ; ***** non space character			*****
                        ; ***************************************************
                        NextFileName:
   20f4   4a            	lda	ra		; move past any spaces
   20f5   ff 20         	smi	' '
   20f7   c2 20 f4      	lbz	NextFileName
   20fa   2a            	dec	ra		; move back to non-space character
   20fb   0a            	ldn	ra		; get byte
   20fc   d5            	retn
                        ;
                        ; ***************************************************
                        ; ***** Exit: return to Elf/OS, restoring OS	*****
                        ; *****       stack and R6 contents		*****
                        ; ***************************************************
                        Exit:
   20fd   9e            	ghi	re		; restore console echo
   20fe   f9 01         	ori	00000001b
   2100   be            	phi	re
   2101   f8 01         	ldi     1		; assume interrupts are enabled
   2103   cc            	lsie			; skip if they are
   2104   f8 00         	ldi	0		; mark interrupts disabled
   2106   ae            	plo	re		; save IE flag
   2107   f8 23         	ldi	023h		; setup for DIS (X=2, P=3)
   2109   52            	str	r2
   210a   71            	dis			; disable interrupts
   210b   22            	dec	r2
   210c   f8 31 bf f8   	load	rf,saveStack	; restore Elf/OS's stack
   2110   8c af         
   2112   4f            	lda	rf
   2113   b2            	phi	r2
   2114   0f            	ldn	rf
   2115   a2            	plo	r2
   2116   8e            	glo	re		; recover IE flag
   2117   c2 21 1f      	lbz	Exit2		; jump if interrupts were disabled
   211a   f8 23         	ldi	023h		; setup for RET (X=2, P=3)
   211c   52            	str	r2
   211d   70            	ret			; re-enable interrupts
   211e   22            	dec	r2
                        Exit2:
   211f   60 72 b6 f0   	pop	r6		; restore Elf/OS's return address
   2123   a6            
   2124   d5            	retn			; return to Elf/OS
                        ;
                        ; ***************************************************
                        ; ***** Process file: if a directory file,	*****
                        ; ***** send each ordinary file contained in it	*****
                        ; ***** If an ordinary file, just send it  	*****
                        ; ***** RA: points to file name			*****
                        ; ***************************************************
                        ProcFile:
   2125   f8 31 bd f8   	load	rd,cmdFilename	; copy filename from cmd tail
   2129   8e ad         
   212b   f8 32 bc f8   	load	rc,sndFilename
   212f   0e ac         
                        ProcCopyName:
   2131   4a            	lda	ra		; look for first less <= space
   2132   5d            	str	rd
   2133   1d            	inc	rd
   2134   5c            	str	rc
   2135   1c            	inc	rc
   2136   ff 21         	smi	' '+1
   2138   c3 21 31      	lbdf	ProcCopyName
   213b   2a            	dec	ra
   213c   2d            	dec	rd
   213d   f8 00         	ldi	0		; zero terminate filename
   213f   5d            	str	rd
   2140   1d            	inc	rd
   2141   2c            	dec	rc
   2142   5c            	str	rc
   2143   8d 73 9d 73   	push	rd		; save block ptr
   2147   f8 20 bd f8   	load	rd,CmdFilDes	; get file descriptor
   214b   2c ad         
   214d   f8 31 bf f8   	load	rf,cmdFilename
   2151   8e af         
   2153   f8 00         	ldi	0		; flags for open, append
   2155   a7            	plo	r7
   2156   d4 03 06      	call	O_OPEN		; attempt to open file to determine size
   2159   cb 21 86      	lbnf	CmdFileOpened	; jump if file was opened
   215c   d4 25 9f      	call	Cancel
   215f   d4 03 4b      	call	O_INMSG
   2162   43 6f 75 6c   	db	'Couldn',27h,'t open file: ',0
   2166   64 6e 27 74   
   216a   20 6f 70 65   
   216e   6e 20 66 69   
   2172   6c 65 3a 20   
   2176   00            
   2177   f8 31 bf f8   	load	rf,cmdFilename
   217b   8e af         
   217d   d4 03 33      	call	O_MSG		; display it
   2180   d4 27 a8      	call	crlf
   2183   c0 20 fd      	lbr	Exit		; and return to os
                        CmdFileOpened:
   2186   f8 20 bd f8   	load	rd,CmdFilDes
   218a   2c ad         
                        ;
   218c   8f 73 9f 73   	push	rf
   2190   f8 e0         	ldi	0e0h		; lba mode
   2192   b8            	phi	r8
   2193   f8 20 bf f8   	load	rf,CmdDirSec+1	; point to dir sector in CmdFilDes
   2197   36 af         
   2199   4f            	lda	rf		; retrieve sector
   219a   a8            	plo	r8
   219b   4f            	lda	rf
   219c   b7            	phi	r7
   219d   4f            	lda	rf
   219e   a7            	plo	r7
   219f   f8 32 bf f8   	load	rf,DirBuffer	; where to load sector
   21a3   8e af         
   21a5   d4 ff 3c      	call	f_ideread	; call bios to read the sector
                        ;
   21a8   f8 20 bf f8   	load	rf,CmdDirOfs+1	; need dirent offset
   21ac   3a af         
   21ae   0f            	ldn	rf
   21af   fc 06         	adi	6		; point to flags
   21b1   ad            	plo	rd
   21b2   2f            	dec	rf
   21b3   0f            	ldn	rf
   21b4   7c 00         	adci	0		; propagate carry
   21b6   bd            	phi	rd		; r7 now points to flags
   21b7   8d            	glo	rd		; now point to correct spot in sector buffer
   21b8   fc 8e         	adi	low DirBuffer
   21ba   ad            	plo	rd
   21bb   9d            	ghi	rd
   21bc   7c 32         	adci	high Dirbuffer
   21be   bd            	phi	rd
                        ;
   21bf   0d            	ldn	rd		; get flags
   21c0   73            	pushd
                        	
   21c1   fa 01         	ani	ff_dir
   21c3   3a e1         	bnz	isDirFile
                        ;
   21c5   f8 20 bd f8   	load	rd,CmdFilDes
   21c9   2c ad         
   21cb   d4 03 12      	call	O_CLOSE
   21ce   8a 73 9a 73   	push	ra		; save cmd tail ptr
   21d2   f8 31 ba f8   	load	ra,cmdFilename
   21d6   8e aa         
   21d8   d4 22 63      	call	SendFile	; ordinary file, just send it
   21db   60 72 ba f0   	pop	ra
   21df   aa            
   21e0   d5            	retn
                        isDirFile:
   21e1   f8 00 bc f8   	load	rc,32		; read next directory entry
   21e5   20 ac         
   21e7   f8 34 bf f8   	load	rf,dirEntBuffer
   21eb   8e af         
   21ed   f8 20 bd f8   	load	rd,CmdFilDes
   21f1   2c ad         
   21f3   d4 03 09      	call	O_READ
   21f6   8c            	glo	rc
   21f7   c2 22 59      	lbz	eofdir		; no more
   21fa   f8 34 bf f8   	load	rf,dirEntBuffer
   21fe   8e af         
   2200   4f            	lda	rf		; see if it has a non zero sector
   2201   ca 22 10      	lbnz	occupied	; (indicates in-use file)
   2204   4f            	lda	rf
   2205   ca 22 10      	lbnz	occupied
   2208   4f            	lda	rf
   2209   ca 22 10      	lbnz	occupied
   220c   4f            	lda	rf
   220d   c2 21 e1      	lbz	isDirFile
                        occupied:
   2210   f8 34 bf f8   	load	rf,dirEntBuffer+6
   2214   94 af         
   2216   0f            	ldn	rf		; make sure it's not a sub directory
   2217   fa 01         	ani	ff_dir
   2219   ca 21 e1      	lbnz	isDirFile
   221c   8a 73 9a 73   	push	ra		; save cmd tail ptr
   2220   f8 31 bf f8   	load	rf,cmdFilename
   2224   8e af         
   2226   f8 32 ba f8   	load	ra,sndFilename
   222a   0e aa         
                        copyDir:
   222c   4f            	lda	rf
   222d   5a            	str	ra
   222e   1a            	inc	ra
   222f   3a 2c         	bnz	copyDir
   2231   2a            	dec	ra		; point back to terminator
   2232   2a            	dec	ra		; point back to last char of dir
   2233   0a            	ldn	ra
   2234   ff 2f         	smi	'/'
   2236   32 3c         	bz	hasTrailingSlash
   2238   1a            	inc	ra
   2239   f8 2f         	ldi	'/'
   223b   5a            	str	ra
                        hasTrailingSlash:
   223c   1a            	inc	ra
   223d   f8 34 bf f8   	load	rf,dirEntBuffer+12
   2241   9a af         
                        copyFileName:
   2243   4f            	lda	rf
   2244   5a            	str	ra
   2245   1a            	inc	ra
   2246   3a 43         	bnz	copyFileName
   2248   f8 32 ba f8   	load	ra,sndFilename
   224c   0e aa         
   224e   d4 22 63      	call	SendFile	; send file from directory entry
   2251   60 72 ba f0   	pop	ra		; restore cmd tail ptr
   2255   aa            
   2256   c0 21 e1      	lbr	isDirFile
                        eofdir:
   2259   f8 20 bd f8   	load	rd,CmdFilDes
   225d   2c ad         
   225f   d4 03 12      	call	O_CLOSE
   2262   d5            	retn
                        ;
                        ; ***************************************************
                        ; ***** Send file: send a single file	  	*****
                        ; ***** RA: points to file name			*****
                        ; ***************************************************
                        SendFile:
   2263   d4 25 8e      	call	ZeroBlock0
   2266   f8 34 bd f8   	load	rd,block0	; copy filename to block
   226a   be ad         
   226c   0a            	ldn	ra		; don't allow leading /
   226d   ff 2f         	smi	'/'
   226f   3a 72         	bnz	B0loop1		; jump if not an absolute path
   2271   1a            	inc	ra		; make it a relative path
                        B0loop1:
   2272   4a            	lda	ra		; look for first less <= space
   2273   5d            	str	rd
   2274   1d            	inc	rd
   2275   ff 21         	smi	' '+1
   2277   c3 22 72      	lbdf	B0loop1
   227a   2a            	dec	ra
   227b   2d            	dec	rd
   227c   1d            	inc	rd		; skip over 0 terminator
   227d   8d 73 9d 73   	push	rd		; save block ptr
   2281   f8 20 bd f8   	load	rd,SndFilDes	; get file descriptor
   2285   3f ad         
   2287   f8 32 bf f8   	load	rf,sndFilename
   228b   0e af         
   228d   f8 04         	ldi	O_APPND		; flags for open, append
   228f   a7            	plo	r7
   2290   d4 03 06      	call	O_OPEN		; attempt to open file to determine size
   2293   cb 22 c0      	lbnf	SndFileOpened	; jump if file was opened
   2296   d4 25 9f      	call	Cancel
   2299   d4 03 4b      	call	O_INMSG
   229c   43 6f 75 6c   	db	'Couldn',27h,'t open file: ',0
   22a0   64 6e 27 74   
   22a4   20 6f 70 65   
   22a8   6e 20 66 69   
   22ac   6c 65 3a 20   
   22b0   00            
   22b1   f8 32 bf f8   	load	rf,sndFilename
   22b5   0e af         
   22b7   d4 03 33      	call	O_MSG		; display it
   22ba   d4 27 a8      	call	crlf
   22bd   c0 20 fd      	lbr	Exit		; and return to os
                        SndFileOpened:
   22c0   f8 20 bd f8   	load	rd,SndFilDes
   22c4   3f ad         
   22c6   f8 34 bf f8   	load	rf,fileSize
   22ca   ba af         
   22cc   4d            	lda	rd		; put 32 bit offset into
   22cd   b7            	phi	r7		; R7:R8 and fileSize
   22ce   5f            	str	rf
   22cf   1f            	inc	rf
                        ;
   22d0   4d            	lda	rd
   22d1   a7            	plo	r7
   22d2   5f            	str	rf
   22d3   1f            	inc	rf
                        ;
   22d4   4d            	lda	rd
   22d5   b8            	phi	r8
   22d6   5f            	str	rf
   22d7   1f            	inc	rf
                        ;
   22d8   0d            	ldn	rd
   22d9   a8            	plo	r8
   22da   5f            	str	rf
                        ;
   22db   2d            	dec	rd		; restore descriptor
   22dc   2d            	dec	rd
   22dd   2d            	dec	rd
                        ;
   22de   87 73 97 73   	push	r7
   22e2   88 73 98 73   	push	r8
                        ;
   22e6   f8 00 b8 f8   	load	r8,0
   22ea   00 a8         
   22ec   f8 00 b7 f8   	load	r7,0
   22f0   00 a7         
   22f2   f8 20 bd f8   	load	rd,SndFilDes
   22f6   3f ad         
   22f8   f8 00 bc f8   	load	rc,0		; rewind file to start
   22fc   00 ac         
   22fe   d4 03 0f      	call	O_SEEK
                        ;
   2301   60 72 b8 f0   	pop	r8
   2305   a8            
   2306   60 72 b7 f0   	pop	r7
   230a   a7            
   230b   60 72 bf f0   	pop	rf		; restore block ptr
   230f   af            
   2310   d4 27 af      	call	uint32_out	; convert number to ascii
   2313   f8 20         	ldi	' '		; finish file size with space	
   2315   5f            	str	rf
   2316   1f            	inc	rf
                        ;
   2317   8a 73 9a 73   	push	ra
   231b   8f 73 9f 73   	push	rf
   231f   f8 e0         	ldi	0e0h		; lba mode
   2321   b8            	phi	r8
   2322   f8 20 bf f8   	load	rf,SndDirSec+1	; point to dir sector in SndFilDes
   2326   49 af         
   2328   4f            	lda	rf		; retrieve sector
   2329   a8            	plo	r8
   232a   4f            	lda	rf
   232b   b7            	phi	r7
   232c   4f            	lda	rf
   232d   a7            	plo	r7
   232e   f8 32 bf f8   	load	rf,DirBuffer	; where to load sector
   2332   8e af         
   2334   d4 ff 3c      	call	f_ideread	; call bios to read the sector
                        ;
   2337   f8 20 bf f8   	load	rf,SndDirOfs+1	; need dirent offset
   233b   4d af         
   233d   0f            	ldn	rf
   233e   fc 07         	adi	7		; point to date block
   2340   aa            	plo	ra
   2341   2f            	dec	rf
   2342   0f            	ldn	rf
   2343   7c 00         	adci	0		; propagate carry
   2345   ba            	phi	ra		; r7 now points to date block
   2346   8a            	glo	ra		; now point to correct spot in sector buffer
   2347   fc 8e         	adi	low DirBuffer
   2349   aa            	plo	ra
   234a   9a            	ghi	ra
   234b   7c 32         	adci	high DirBuffer
   234d   ba            	phi	ra
                        ;
   234e   f8 34 bf f8   	load	rf,year
   2352   ae af         
   2354   4a            	lda	ra		; get year/month
   2355   f6            	shr			; shift high month bit into DF
   2356   0a            	ldn	ra		; get low bits of month
   2357   76            	shrc			; shift high bit in
   2358   f6            	shr			; then shift into position
   2359   f6            	shr
   235a   f6            	shr
   235b   f6            	shr
   235c   1f            	inc	rf
   235d   5f            	str	rf		; store month
   235e   1f            	inc	rf		; point to day storage
   235f   0a            	ldn	ra		; recover day
   2360   fa 1f         	ani	31		; mask for day
   2362   5f            	str	rf		; store day
   2363   2f            	dec	rf
   2364   2f            	dec	rf		; point back to year offset storage
   2365   2a            	dec	ra		; point back to year
   2366   4a            	lda	ra		; get year
   2367   f6            	shr			; shift out high bit of month
   2368   5f            	str	rf		; store year offset from 1972
   2369   1f            	inc	rf
   236a   1f            	inc	rf
   236b   1f            	inc	rf		; point to hours storage
   236c   1a            	inc	ra		; point to time
   236d   0a            	ldn	ra		; retrieve hours
   236e   f6            	shr			; shift to proper position
   236f   f6            	shr
   2370   f6            	shr
   2371   5f            	str	rf		; store hours
   2372   1f            	inc	rf		; point to minutes storage
   2373   4a            	lda	ra		; get minutes
   2374   fa 07         	ani	07h		; strip out hours
   2376   fe            	shl			; shift to needed spot
   2377   fe            	shl
   2378   fe            	shl
   2379   52            	str	r2		; save for combination
   237a   0a            	ldn	ra		; get low bits of minutes
   237b   f6            	shr			; shift into position
   237c   f6            	shr
   237d   f6            	shr
   237e   f6            	shr
   237f   f6            	shr
   2380   f1            	or			; combine with high bites
   2381   5f            	str	rf		; store minutes
   2382   1f            	inc	rf		; point to seconds storage
   2383   0a            	ldn	ra		; get seconds
   2384   fa 1f         	ani	1fh		; strip minutes out
   2386   fe            	shl			; multiply by 2
   2387   5f            	str	rf		; store seconds	
                        ;
   2388   f8 34 bf f8   	load	rf,year		; point back to year
   238c   ae af         
   238e   f8 03 b7 f8   	load	r7,03c2h	; number of seconds
   2392   c2 a7         
   2394   f8 67 b8 f8   	load	r8,6700h	; from Jan 1 1970 to Jan 1 1972
   2398   00 a8         
   239a   0f            	ldn	rf		; year offset from 1972
   239b   a9            	plo	r9
   239c   f8 00         	ldi	0
   239e   b9            	phi	r9		; leap year counter
                        yearLoop:
   239f   89            	glo	r9
   23a0   32 cd         	bz	yearsDone
   23a2   f8 01 ba f8   	load	ra,01e1h	; seconds in a year
   23a6   e1 aa         
   23a8   f8 33 bb f8   	load	rb,3380h
   23ac   80 ab         
   23ae   d4 28 6d      	call	add32bits
   23b1   99            	ghi	r9
   23b2   fa 03         	ani	00000011b
   23b4   3a c5         	bnz	notLeapYear
   23b6   f8 00 ba f8   	load	ra,0001h	; seconds in the leap day
   23ba   01 aa         
   23bc   f8 51 bb f8   	load	rb,5180h	; (86400)
   23c0   80 ab         
   23c2   d4 28 6d      	call	add32bits
                        notLeapYear:
   23c5   99            	ghi	r9
   23c6   29            	dec	r9
   23c7   fc 01         	adi	1
   23c9   b9            	phi	r9
   23ca   c0 23 9f      	lbr	yearLoop
                        yearsDone:
   23cd   f8 00 ba f8   	load	ra,0001h	; seconds in a day
   23d1   01 aa         
   23d3   f8 51 bb f8   	load	rb,5180h	; (86400)
   23d7   80 ab         
   23d9   4f            	lda	rf		; re-get year
   23da   fa 03         	ani	00000011b	; rc.1 will be 0 if leap year
   23dc   bc            	phi	rc		; 
   23dd   4f            	lda	rf		; month # (1-12)
   23de   ff 01         	smi	1
   23e0   c2 24 06      	lbz	monthsDone
   23e3   ac            	plo	rc		; rc.0 is month # -1
   23e4   f8 20 bd f8   	load	rd,monthDays
   23e8   20 ad         
                        monthsLoop:
   23ea   4d            	lda	rd
   23eb   a9            	plo	r9		; rb.0 is # days in month
                        monthLoop:
   23ec   d4 28 6d      	call	add32bits	; add a day's worth of seconds
   23ef   29            	dec	r9		; decrement days left in month
   23f0   89            	glo	r9
   23f1   ca 23 ec      	lbnz	monthLoop
   23f4   9c            	ghi	rc		; leap year?
   23f5   3a ff         	bnz	noLeapYearChk
   23f7   8d            	glo	rd		; test for February
   23f8   ff 22         	smi	low monthDays+2
   23fa   3a ff         	bnz	notFebruary
   23fc   d4 28 6d      	call	add32bits	; add in another day in Feb in leap year	
                        noLeapYearChk:
                        notFebruary:
   23ff   8c            	glo	rc
   2400   ff 01         	smi	1
   2402   ac            	plo	rc
   2403   ca 23 ea      	lbnz	monthsLoop
                        monthsDone:
   2406   4f            	lda	rf		; day of month
   2407   ff 01         	smi	1
   2409   c2 24 15      	lbz	domDone
   240c   a9            	plo	r9
                        domLoop:
   240d   d4 28 6d      	call	add32bits
   2410   29            	dec	r9
   2411   89            	glo	r9
   2412   ca 24 0d      	lbnz	domLoop
                        domDone:
   2415   f8 00 ba f8   	load	ra,0
   2419   00 aa         
   241b   f8 0e bb f8   	load	rb,3600		; seconds in an hour
   241f   10 ab         
   2421   4f            	lda	rf
   2422   32 2c         	bz	hoursDone
   2424   a9            	plo	r9
                        hoursLoop:
   2425   d4 28 6d      	call	add32bits
   2428   29            	dec	r9
   2429   89            	glo	r9
   242a   3a 25         	bnz	hoursLoop
                        hoursDone:
   242c   f8 00 bb f8   	load	rb,60		; seconds in a minute
   2430   3c ab         
   2432   4f            	lda	rf
   2433   c2 24 3f      	lbz	minutesDone
   2436   a9            	plo	r9
                        minutesLoop:
   2437   d4 28 6d      	call	add32bits
   243a   29            	dec	r9
   243b   89            	glo	r9
   243c   ca 24 37      	lbnz	minutesLoop
                        minutesDone:
   243f   0f            	ldn	rf		; get seconds
   2440   ab            	plo	rb
   2441   d4 28 6d      	call	add32bits
                        ;
   2444   60 72 bf f0   	pop	rf		; restore block 0 ptr
   2448   af            
   2449   f8 0c         	ldi	'0' shr 2	; convert r7:r8 to octal number
   244b   b9            	phi	r9		; and add to block 0 string
   244c   f8 02         	ldi	2		; 2 bits on first digit
   244e   a9            	plo	r9
   244f   f8 0b         	ldi	11		; 11 digits in a 32 bit number
   2451   aa            	plo	ra
                        bitLoop:
   2452   88            	glo	r8
   2453   fe            	shl
   2454   a8            	plo	r8
   2455   98            	ghi	r8
   2456   7e            	shlc
   2457   b8            	phi	r8
   2458   87            	glo	r7
   2459   7e            	shlc
   245a   a7            	plo	r7
   245b   97            	ghi	r7
   245c   7e            	shlc
   245d   b7            	phi	r7
   245e   99            	ghi	r9
   245f   7e            	shlc
   2460   29            	dec	r9
   2461   b9            	phi	r9
   2462   89            	glo	r9
   2463   ca 24 52      	lbnz	bitLoop
   2466   99            	ghi	r9
   2467   5f            	str	rf
   2468   1f            	inc	rf
   2469   f8 06         	ldi	'0' shr 3	; next octal digit setup
   246b   b9            	phi	r9
   246c   f8 03         	ldi	3		; 3 bits for remaining digits
   246e   a9            	plo	r9
   246f   2a            	dec	ra
   2470   8a            	glo	ra
   2471   ca 24 52      	lbnz	bitLoop
                        ;
   2474   60 72 ba f0   	pop	ra
   2478   aa            
                        ;
   2479   f8 20         	ldi	' '		; finish timestamp with space	
   247b   5f            	str	rf
   247c   1f            	inc	rf
   247d   f8 30         	ldi	'0'		; default file mode to '0'
   247f   5f            	str	rf		; no trailing nul needed: already 0'd
                        ;
   2480   d4 25 c3      	call	WaitNAKorCRC
   2483   ff 43         	smi	crc
   2485   c2 24 99      	lbz	CrcMode
   2488   ff d2         	smi	nak-crc
   248a   c2 24 9b      	lbz	SaveMode
                        SendFileError:
   248d   f8 20 bd f8   	load	rd,SndFilDes
   2491   3f ad         
   2493   d4 03 12      	call	O_CLOSE
   2496   ff 00         	smi	0		; DF=1, error
   2498   d5            	retn
                        CrcMode:
   2499   f8 01         	ldi	1
                        SaveMode:
   249b   a7            	plo	r7
   249c   f8 34 bf f8   	load	rf,blkMode
   24a0   b9 af         
   24a2   87            	glo	r7
   24a3   5f            	str	rf
                        ;
                        	 if	debug=0
   24a4   f8 27 bf f8   	load	rf,SoftAckedAction
   24a8   44 af         
   24aa   f8 5c         	ldi	low SoftReadne2
   24ac   5f            	str	rf
   24ad   f8 26 bf f8   	load	rf,HardAckedAction
   24b1   83 af         
   24b3   f8 26         	ldi	high HardAcked
   24b5   5f            	str	rf
   24b6   1f            	inc	rf
   24b7   f8 92         	ldi	low HardAcked
   24b9   5f            	str	rf
                        	 endi
   24ba   f8 34 bf f8   	load	rf,blkNum
   24be   b8 af         
   24c0   f8 00         	ldi	0
   24c2   5f            	str	rf
   24c3   f8 34 bf f8   	load	rf,block0
   24c7   be af         
   24c9   f8 00 bc f8   	load	rc,128
   24cd   80 ac         
   24cf   f8 0a         	ldi	10
   24d1   a8            	plo	r8
   24d2   d4 26 09      	call	SendBlock	; send file block 0
   24d5   c3 24 8d      	lbdf	SendFileError
                        ;
                        	 if	debug
                        	pushd
                        	call	crlf
                        	load	rf,hexcount
                        	ldi	0
                        	str	rf
                        	popd
                        	 endif
                        ;
   24d8   ff 43         	smi	crc
   24da   32 e0         	bz	fileSendLoop
   24dc   ff d2         	smi	nak-crc
   24de   3a 8d         	bnz	SendFileError
                        ;
                        FileSendLoop:
   24e0   f8 34 bf f8   	load	rf,fileSize
   24e4   ba af         
   24e6   f8 04 bc f8   	load	rc,1024		; assume we've got at least 1K
   24ea   00 ac         
   24ec   4f            	lda	rf		; left to send
   24ed   ca 25 08      	lbnz	MoreToGo
   24f0   4f            	lda	rf
   24f1   ca 25 08      	lbnz	MoreToGo
   24f4   0f            	ldn	rf
   24f5   ff 04         	smi	high 1024
   24f7   c3 25 08      	lbdf	MoreToGo	; jump if >= 1K left to go
                        NearingTheEnd:
   24fa   f8 00 bc f8   	load	rc,128		; switch to 128 byte sectors
   24fe   80 ac         
   2500   4f            	lda	rf
   2501   ca 25 08      	lbnz	MoreToGo
   2504   0f            	ldn	rf
   2505   c2 25 7a      	lbz	FileDone
                        MoreToGo:
   2508   8c 73 9c 73   	push	rc
   250c   f8 20 bd f8   	load	rd,SndFilDes
   2510   3f ad         
   2512   f8 35 bf f8   	load	rf,blockBuffer
   2516   3e af         
   2518   d4 03 09      	call	O_READ
   251b   8c            	glo	rc
   251c   ca 25 23      	lbnz	ReadBytes
   251f   9c            	ghi	rc
   2520   c2 25 75      	lbz	FileDonePop
                        ReadBytes:
   2523   f8 34 bf f8   	load	rf,fileSize+3	; LSB
   2527   bd af         
                        ;
   2529   8c            	glo	rc		; decrement fileSize by
   252a   52            	str	r2		; # bytes read
   252b   0f            	ldn	rf
   252c   f7            	sm
   252d   5f            	str	rf
                        ;
   252e   2f            	dec	rf
   252f   9c            	ghi	rc
   2530   52            	str	r2
   2531   0f            	ldn	rf
   2532   77            	smb
   2533   5f            	str	rf
                        ;
   2534   2f            	dec	rf
   2535   0f            	ldn	rf
   2536   7d 00         	sdbi	0
   2538   5f            	str	rf
                        ;
   2539   2f            	dec	rf
   253a   0f            	ldn	rf
   253b   7d 00         	sdbi	0
   253d   5f            	str	rf
                        ;
   253e   60 72 bc f0   	pop	rc		; retrieve block size
   2542   ac            
                        	 if	debug=0
   2543   f8 27 bf f8   	load	rf,SoftAckedAction
   2547   44 af         
   2549   f8 81         	ldi	low nextBlock
   254b   5f            	str	rf
   254c   f8 26 bf f8   	load	rf,HardAckedAction
   2550   83 af         
   2552   f8 27         	ldi	high nextBlock
   2554   5f            	str	rf
   2555   1f            	inc	rf
   2556   f8 81         	ldi	low nextBlock
   2558   5f            	str	rf
                        	 endi
   2559   f8 35 bf f8   	load	rf,blockBuffer
   255d   3e af         
   255f   f8 0a         	ldi	10
   2561   a8            	plo	r8
   2562   d4 26 09      	call	SendBlock
   2565   c3 24 8d      	lbdf	SendFileError
   2568   ff 06         	smi	ack
   256a   32 72         	bz	BlockACKed
   256c   d4 25 9f      	call	Cancel
   256f   c0 24 8d      	lbr	SendFileError
                        BlockACKed:
   2572   c0 24 e0      	lbr	fileSendLoop
                        FileDonePop:
   2575   60 72 bc f0   	pop	rc		; discard block size
   2579   ac            
                        FileDone:
   257a   d4 25 ef      	call	SendEOT		; signal file done and get response
   257d   ff 06         	smi	ack		; ACK'd?
   257f   ca 24 8d      	lbnz	SendFileError
   2582   f8 20 bd f8   	load	rd,SndFilDes
   2586   3f ad         
   2588   d4 03 12      	call	O_CLOSE
   258b   fc 00         	adi	0		; DF=0, no error
   258d   d5            	retn			; all done!
                        ;
                        ; ***************************************************
                        ; ***** ZeroBlock0: zeroes block 0		*****
                        ; ***************************************************
                        ZeroBlock0:
   258e   f8 34 bf f8   	load	rf,block0
   2592   be af         
                        ZeroLoop:
   2594   f8 00         	ldi	0
   2596   5f            	str	rf
   2597   1f            	inc	rf
   2598   8f            	glo	rf
   2599   ff 3e         	smi	low (block0+128)
   259b   ca 25 94      	lbnz	ZeroLoop
   259e   d5            	retn
                        ;
                        ; ***************************************************
                        ; ***** Cancel: send 8 CANs followed by 8 BSs	*****
                        ; ***************************************************
                        Cancel:
   259f   87 73 97 73   	push	r7
   25a3   f8 08         	ldi	8
   25a5   a7            	plo	r7
                        cancelLoop:
   25a6   f8 18         	ldi	can
   25a8   d4 ff 4e      	call	TTYout		; send CAN (^X) 8 times
   25ab   27            	dec	r7
   25ac   87            	glo	r7
   25ad   ca 25 a6      	lbnz	cancelLoop
   25b0   f8 08         	ldi	8
   25b2   a7            	plo	r7
                        bsLoop:
   25b3   f8 08         	ldi	bs		; send BS (^H) 8 times
   25b5   d4 ff 4e      	call	TTYout
   25b8   27            	dec	r7
   25b9   87            	glo	r7
   25ba   ca 25 b3      	lbnz	bsLoop
   25bd   60 72 b7 f0   	pop	r7
   25c1   a7            
   25c2   d5            	retn
                        ;
                        ; ***************************************************
                        ; ***** WaitNAKorCRC: wait for CRC or NAK char	*****
                        ; ***************************************************
                        WaitNAKorCRC:
                        	 if	debug
                        	ldi	crc
                        	 else	
   25c3   d4 ff 06      	call	f_read
   25c6   ae            	plo	re
   25c7   ff 43         	smi	crc
   25c9   32 cf         	bz	GotNAKorCRC
   25cb   ff d2         	smi	nak-crc
   25cd   3a c3         	bnz	WaitNAKorCRC
                        GotNAKorCRC:
   25cf   8e            	glo	re
                        	 endi
   25d0   d5            	retn
                        ;
                        ; ***************************************************
                        ; ***** GetACK: wait for ACK/NAK or CAN	char	*****
                        ; ***************************************************
                        GetACK:
                        	 if	debug
                        	ldi	ack
                        	 else
   25d1   d4 ff 06      	call	f_read		; read response to block sent
                        	 endi
   25d4   ae            	plo	re
   25d5   ff 06         	smi	ack
   25d7   c2 25 e7      	lbz	GotACK		; ACK'd, all good
   25da   ff 0f         	smi	nak-ack
   25dc   c2 25 eb      	lbz	DidntGetACK	; NAK'd, probably have to resend
   25df   ff 03         	smi	can-nak
   25e1   c2 25 eb      	lbz	DidntGetACK	; CAN'd, terminating transfer
   25e4   c0 25 d1      	lbr	GetACK
                        GotACK:
   25e7   8e            	glo	re
   25e8   fc 00         	adi	0		; DF = 0, ACKed
   25ea   d5            	retn
                        DidntGetACK:
   25eb   8e            	glo	re
   25ec   ff 00         	smi	0		; DF = 1, not ACKed
   25ee   d5            	retn
                        ;
                        ; ***************************************************
                        ; ***** SendEOT: send EOT, wait for ACK		*****
                        ; ***************************************************
                        SendEOT:
   25ef   f8 04         	ldi	eot
   25f1   d4 ff 4e      	call	TTYout		; send EOT (^D)
                        	 if	debug
                        	call	crlf
                        	push	rf
                        	load	rf,hexcount
                        	ldi	0
                        	str	rf
                        	pop	rf
                        	 else
   25f4   d4 ff 06      	call	f_read
   25f7   ff 06         	smi	ack		; wait for ACK (^F)
   25f9   ca 25 ef      	lbnz	SendEOT
                        	 endi
   25fc   f8 06         	ldi	ack
   25fe   d5            	retn
                        ;
                        ; *******************************************
                        ; ***** Send file block	  		*****
                        ; ***** RF - pointer to block		*****
                        ; ***** RC - Block length		*****
                        ; ***** R8 - # retries			*****
                        ; *******************************************
                        ResendBlock:
   25ff   60 72 bf f0   	pop	rf
   2603   af            
   2604   60 72 bc f0   	pop	rc
   2608   ac            
                        SendBlock:
   2609   8c 73 9c 73   	push	rc
   260d   8f 73 9f 73   	push	rf
   2611   9c            	ghi	rc		; 1K or 128b block?
   2612   c2 26 1a      	lbz	Send128
   2615   f8 02         	ldi	stx		; 1K
   2617   c0 26 1c      	lbr	SendStart
                        Send128:
   261a   f8 01         	ldi	soh		; 128b
                        SendStart:
   261c   d4 ff 4e      	call	TTYout		; SOH/STK
   261f   f8 34 bd f8   	load	rd,blkNum
   2623   b8 ad         
   2625   0d            	ldn	rd
   2626   d4 ff 4e      	call	TTYout		; block #
   2629   0d            	ldn	rd
   262a   fd ff         	sdi	255
   262c   d4 ff 4e      	call	TTYout		; NOT block #
                        ;
   262f   f8 2b         	ldi	high crcTableLow
   2631   b9            	phi	r9
   2632   f8 2c         	ldi	high crcTableHigh
   2634   bb            	phi	rb
                        ;
   2635   f8 00 b7 f8   	load	r7,0
   2639   00 a7         
   263b   f8 34 bd f8   	load	rd,blkMode
   263f   b9 ad         
   2641   0d            	ldn	rd		; 0=checksum, 1=CRC
   2642   c2 26 66      	lbz	SendWithChecksum
                        ;
                        SendWithCRC:
   2645   0f            	ldn	rf
   2646   d4 ff 4e      	call	TTYout		; send data byte
   2649   4f            	lda	rf		; retrieve again and advance ptr
                        ;
   264a   52            	str	r2
   264b   97            	ghi	r7		; j = (crc >> 8) ^ byte
   264c   f3            	xor
   264d   a9            	plo	r9
   264e   ab            	plo	rb
                        ;
   264f   87            	glo	r7		; crc = (crc << 8) ^ table[j]
   2650   eb            	sex	rb
   2651   f3            	xor
   2652   e2            	sex	r2
   2653   b7            	phi	r7
   2654   09            	ldn	r9
   2655   a7            	plo	r7
                        ;
   2656   2c            	dec	rc		; loop while data bytes
   2657   9c            	ghi	rc		; left to send
   2658   ca 26 45      	lbnz	SendWithCRC
   265b   8c            	glo	rc
   265c   ca 26 45      	lbnz	SendWithCRC
                        ;
   265f   97            	ghi	r7		; send hi byte of CRC
   2660   d4 ff 4e      	call	TTYout
                        HardUARTlbr1	equ	$+1
   2663   c0 27 00      	lbr	SoftUARTlastChar
                        ;
                        SendWithChecksum:
   2666   4f            	lda	rf
   2667   52            	str	r2
   2668   87            	glo	r7
   2669   f4            	add
   266a   a7            	plo	r7
   266b   02            	ldn	r2
   266c   d4 ff 4e      	call	TTYout		; send data byte
   266f   2c            	dec	rc
   2670   9c            	ghi	rc
   2671   ca 26 66      	lbnz	SendWithChecksum
   2674   8c            	glo	rc
   2675   ca 26 66      	lbnz	SendWithChecksum
                        HardUARTlbr2	equ	$+1
   2678   c0 27 00      	lbr	SoftUARTlastChar
                        ;
                        ; With a physical UART, we've got no worries about missing the ACK
                        ; after sending the last character of the block, even after block 0
                        ; when we have to handle 2 characters (the ACK/NAK then the CRC/NAK
                        ; character).
                        ;
                        HardUARTlastChar:
   267b   87            	glo	r7
   267c   d4 ff 4e      	call	TTYout		; send checksum or low byte of CRC
   267f   d4 25 d1      	CALL	GetACK
                        HardAckedAction	equ	$+1
   2682   cb 26 92      	lbnf	HardAcked	; block ACK'd
   2685   ff 15         	smi	nak
   2687   ca 27 4e      	lbnz	SendBlockError
   268a   28            	dec	r8		; block NAK'd
   268b   88            	glo	r8		; resend if any retries left
   268c   ca 25 ff      	lbnz	ResendBlock
   268f   c0 27 4e      	lbr	SendBlockError
                        HardAcked:
   2692   d4 25 c3      	call	WaitNAKorCRC
   2695   c0 27 81      	lbr	nextBlock
                        ;
                        	page
                        ;
                        ; BIOS calls weren't quite fast enough to catch the ACK and CRC/NAK
                        ; at the end of a block 0 send. They did manage just the ACK at the end
                        ; of a normal block, most of the time. So, reluctantly, I've had to
                        ; inline the bit banged UART code. I've got some ideas about auto
                        ; patching this to match the machine configuration, but it's all in
                        ; my head at the moment.
                        ;
                        SoftUARTlastChar:
                        	 if debug
                        	glo	r7
                        	call	ttyout
                        	load	rf,blknum
                        	ldn	rf
                        	adi	1
                        	str	rf
                        	load	rf,hexcount
                        	ldi	0
                        	str	rf
                        	call	O_INMSG
                        	db	'acked',cr,lf,0
                        	pop	rf
                        	pop	rc
                        	ldi	ack
                        	adi	0
                        	retn
                        	 else
   2700   f8 09         	ldi	9		; 9 bits to send
   2702   af            	plo	rf
   2703   f8 27 bd f8   	load	rd,delay	; point RD to delay routine
   2707   9e ad         
   2709   dd            	sep	rd
   270a   dd            	sep	rd
   270b   f8 00         	ldi	0
   270d   f6            	shr
   270e   33 13         typelp:	bdf	SoftTxHigh	; jump if 1 bit
                        SoftTxLow:
   2710   7a            	req			; reset output
   2711   30 16         	br	typect
                        SoftTxHigh:
   2713   7b            	seq			; set output
   2714   30 16         	br	typect
   2716   dd            typect:	sep	rd		; perform bit delay
   2717   e2            	sex	r2
   2718   e2            	sex	r2
   2719   87            	glo	r7
   271a   76            	shrc
   271b   a7            	plo	r7
   271c   2f            	dec	rf
   271d   8f            	glo	rf
   271e   3a 0e         	bnz	typelp
                        SoftTxStop:
   2720   7a            	req			; set stop bits
   2721   dd            	sep	rd		; wait half the pulse width
   2722   dd            	sep	rd		; wait another half the pulse width
                        readne:
   2723   f8 09         	ldi	9		; 8 bits to receive
   2725   af            	plo	rf
   2726   9e            	ghi	re		; first delay is half bit size
   2727   bf            	phi	rf
   2728   f6            	shr
   2729   f6            	shr
   272a   be            	phi	re
                        SoftRxStart1:
   272b   3c 2b         	bn1	$		; wait for transmission
   272d   dd            	sep	rd		; wait half the pulse width
   272e   9f            	ghi	rf		; recover baud constant
   272f   be            	phi	re
                        recvnelp:
   2730   9f            	ghi	rf
   2731   f6            	shr			; shift right
                        SoftRxBit1:
   2732   34 99         	b1	recvnelp0	; jump if zero bi
   2734   f9 80         	ori	128		; set bit
                        recvnelp1:
   2736   bf            	phi	rf
   2737   dd            	sep	rd		; perform bit delay
   2738   2f            	dec	rf		; decrement bit count
   2739   c4            	nop
   273a   c4            	nop
   273b   8f            	glo	rf		; check for zero
   273c   3a 30         	bnz	recvnelp	; loop if not
                        recvnedn:
   273e   dd            	sep	rd
   273f   9f            	ghi	rf		; get character
   2740   ae            	plo	re
                        
   2741   ff 06         	smi	ack
                        SoftAckedAction equ	$+1
   2743   32 5c         	bz	SoftReadne2	; block ACK'd
   2745   ff 0f         	smi	nak-ack
   2747   3a 4e         	bnz	SendBlockError
   2749   28            	dec	r8		; block NAK'd
   274a   88            	glo	r8		; resend if any retries left
   274b   ca 25 ff      	lbnz	ResendBlock
                        SendBlockError:
   274e   60 72 bf f0   	pop	rf
   2752   af            
   2753   60 72 bc f0   	pop	rc
   2757   ac            
   2758   8e            	glo	re
   2759   ff 00         	smi	0		; DF = 1, error
   275b   d5            	retn
                        SoftReadne2:
   275c   f8 09         	ldi	9		; 8 bits to receive
   275e   af            	plo	rf
   275f   9e            	ghi	re		; first delay is half bit size
   2760   bf            	phi	rf
   2761   f6            	shr
   2762   f6            	shr
   2763   be            	phi	re
                        SoftRxStart2:
   2764   3c 64         	bn1	$		; wait for transmission
   2766   dd            	sep	rd		; wait half the pulse width
   2767   9f            	ghi	rf		; recover baud constant
   2768   be            	phi	re
                        recvne2lp:
   2769   9f            	ghi	rf
   276a   f6            	shr			; shift right
                        SoftRxBit2:
   276b   34 9b         	b1	recvne2lp0	; jump if zero bi
   276d   f9 80         	ori	128		; set bit
                        recvne2lp1:
   276f   bf            	phi	rf
   2770   dd            	sep	rd		; perform bit delay
   2771   2f            	dec	rf		; decrement bit count
   2772   c4            	nop
   2773   c4            	nop
   2774   8f            	glo	rf		; check for zero
   2775   3a 69         	bnz	recvne2lp	; loop if not
                        recvne2dn:
   2777   9f            	ghi	rf		; get character
   2778   ae            	plo	re
   2779   ff 43         	smi	crc
   277b   32 81         	bz	nextBlock
   277d   ff d2         	smi	nak-crc
   277f   3a 4e         	bnz	SendBlockError
                        nextBlock:
   2781   f8 34 bf f8   	load	rf,blkNum
   2785   b8 af         
   2787   0f            	ldn	rf
   2788   fc 01         	adi	1
   278a   5f            	str	rf
   278b   60 72 bf f0   	pop	rf
   278f   af            
   2790   60 72 bc f0   	pop	rc
   2794   ac            
   2795   8e            	glo	re
   2796   fc 00         	adi	0		; DF = 0, ok
   2798   d5            	retn
                        recvnelp0:
   2799   30 36         	br	recvnelp1	; equalize between 0 and 1
                        recvne2lp0:
   279b   30 6f         	br	recvne2lp1	; equalize between 0 and 1
                        ;
   279d   d3            delayX:	sep	r3
   279e   9e            delay:	ghi	re		; get baud constant
   279f   f6            	shr			; remove echo flag
   27a0   ae            	plo	re		; put into counter
   27a1   e2            	sex	r2		; waste a cycle
   27a2   2e            delay1:	dec	re		; decrement counter
   27a3   8e            	glo	re		; get count
   27a4   32 9d         	bz	delayX		; return if zero
   27a6   30 a2         	br	delay1		; otherwise keep going
                        	 endi
                        ;
                        ; ***************************************************
                        ; ***** Start a new line on the terminal	*****
                        ; ***************************************************
                        crlf:
   27a8   d4 03 4b      	call	O_INMSG
   27ab   0d 0a 00      	db	cr,lf,0
   27ae   d5            	retn
                        ;
                        ; ***************************************************
                        ; ***** Convert 32-bit unsigned int to ASCII	*****
                        ; ***** using the double-dabble algorithm	*****
                        ; ***** (AKA shift and add 3)			*****
                        ; ***** R7:R8 - 32-bit integer			*****
                        ; ***** RF - destination buffer	pointer		*****
                        ; ***************************************************
                        UINT32_DIGITS	EQU	10	; maximum of 10 digits in result
                        UINT32_BITS	EQU	32	; how many bits did you THINK there'd be???
                        
                        uint32_out:
   27af   8d 73 9d 73   	push	rd		; save consumed registers
   27b3   89 73 99 73   	push	r9
   27b7   88 73 98 73   	push	r8
   27bb   87 73 97 73   	push	r7
   27bf   f8 31 bd f8   	load	rd,uint32_buf	; RD is output buffer
   27c3   00 ad         
                        itoa1:	
   27c5   8d 73 9d 73   	push	rd		; save buffer pointer
   27c9   f8 0a         	ldi	UINT32_DIGITS	; clear out BCD buffer
   27cb   ae            	plo	re
                        tobcdlp1:
   27cc   f8 00         	ldi	0
   27ce   5d            	str	rd		; store into answer
   27cf   1d            	inc	rd
   27d0   2e            	dec	re		; decrement count
   27d1   8e            	glo	re
   27d2   ca 27 cc      	lbnz	tobcdlp1	; loop until done
   27d5   60 72 bd f0   	pop	rd		; recover buffer pointer
   27d9   ad            
   27da   f8 20         	ldi	UINT32_BITS	; 32 bits to process
   27dc   a9            	plo	r9
                        tobcdlp2:
   27dd   f8 0a         	ldi	UINT32_DIGITS	; process all 10 digits
   27df   ae            	plo	re		; for digits >= 5
   27e0   8d 73 9d 73   	push	rd		; save buffer pointer
                        tobcdlp3:
   27e4   0d            	ldn	rd		; get byte
   27e5   ff 05         	smi	5		; need to see if 5 or greater
   27e7   cb 27 ed      	lbnf	tobcdlp3a	; jump if not
   27ea   fc 08         	adi	5+3		; add 3 to original number
   27ec   5d            	str	rd		; and put it back
                        tobcdlp3a:
   27ed   1d            	inc	rd		; point to next cell
   27ee   2e            	dec	re		; decrement cell count
   27ef   8e            	glo	re		; retrieve count
   27f0   ca 27 e4      	lbnz	tobcdlp3	; loop back if not done
                        	
   27f3   88            	glo	r8		; shift 32 bit binary number
   27f4   fe            	shl			; 1 bit left
   27f5   a8            	plo	r8
   27f6   98            	ghi	r8
   27f7   7e            	shlc
   27f8   b8            	phi	r8
   27f9   87            	glo	r7
   27fa   7e            	shlc
   27fb   a7            	plo	r7
   27fc   97            	ghi	r7
   27fd   7e            	shlc
   27fe   b7            	phi	r7
                        	
   27ff   7e            	shlc			; now shift result to bit 3
   2800   fe            	shl
   2801   fe            	shl
   2802   fe            	shl
   2803   5d            	str	rd
   2804   60 72 bd f0   	pop	rd		; recover address
   2808   ad            
   2809   8d 73 9d 73   	push	rd		; save address again
   280d   f8 0a         	ldi	UINT32_DIGITS	; 10 BCD digits to process
   280f   ae            	plo	re
                        tobcdlp4:
   2810   4d            	lda	rd		; get current cell
   2811   52            	str	r2		; save it
   2812   0d            	ldn	rd		; get next cell
   2813   f6            	shr			; shift bit 3 into df
   2814   f6            	shr
   2815   f6            	shr
   2816   f6            	shr
   2817   02            	ldn	r2		; recover value for current cell
   2818   7e            	shlc			; shift with new bit
   2819   fa 0f         	ani	00001111b	; keep only bottom 4 bits
   281b   2d            	dec	rd		; point back
   281c   5d            	str	rd		; store value
   281d   1d            	inc	rd		; and move to next cell
   281e   2e            	dec	re		; decrement count
   281f   8e            	glo	re		; see if done
   2820   ca 28 10      	lbnz	tobcdlp4	; jump if not
   2823   60 72 bd f0   	pop	rd		; recover address
   2827   ad            
   2828   29            	dec	r9		; decrement bit count
   2829   89            	glo	r9		; see if done
   282a   ca 27 dd      	lbnz	tobcdlp2	; loop until done
                        ;
   282d   f8 31 bd f8   	load	rd,uint32_buf
   2831   00 ad         
   2833   f8 0a         	ldi	UINT32_DIGITS
   2835   a8            	plo	r8
   2836   f8 09         	ldi	UINT32_DIGITS-1	; max 9 leading zeros
   2838   b8            	phi	r8
   2839   4d            loop1:	lda	rd
   283a   c2 28 63      	lbz	uint32outz	; check leading zeros
   283d   52            	str	r2		; save for a moment
   283e   f8 00         	ldi	0		; signal no more leading zeros
   2840   b8            	phi	r8
   2841   02            	ldn	r2		; recover character
   2842   fc 30         itoa2:	adi	'0'
   2844   5f            	str	rf		; store into output buffer
   2845   1f            	inc	rf
   2846   28            itoa3:	dec	r8
   2847   88            	glo	r8
   2848   ca 28 39      	lbnz	loop1
   284b   f8 00         	ldi	0		; place terminator in destination
   284d   5f            	str	rf
   284e   60 72 b7 f0   	pop	r7
   2852   a7            
   2853   60 72 b8 f0   	pop	r8		; recover consumed registers
   2857   a8            
   2858   60 72 b9 f0   	pop	r9
   285c   a9            
   285d   60 72 bd f0   	pop	rd
   2861   ad            
   2862   d5            	retn			; return to caller
                        
                        uint32outz:
   2863   98            	ghi	r8		; see if leading have been used up
   2864   c2 28 42      	lbz	itoa2		; jump if so
   2867   ff 01         	smi	1		; decrement count
   2869   b8            	phi	r8
   286a   c0 28 46      	lbr	itoa3		; and loop for next character
                        ;
                        ; ***************************************************
                        ; ***** add32bits: r7:r8 = r7:r8 + ra:rb	*****
                        ; ***************************************************
                        add32bits:
   286d   8b            	glo	rb
   286e   52            	str	r2
   286f   88            	glo	r8
   2870   f4            	add
   2871   a8            	plo	r8
   2872   9b            	ghi	rb
   2873   52            	str	r2
   2874   98            	ghi	r8
   2875   74            	adc
   2876   b8            	phi	r8
   2877   8a            	glo	ra
   2878   52            	str	r2
   2879   87            	glo	r7
   287a   74            	adc
   287b   a7            	plo	r7
   287c   9a            	ghi	ra
   287d   52            	str	r2
   287e   97            	ghi	r7
   287f   74            	adc
   2880   b7            	phi	r7
   2881   d5            	retn
                        ;
                        ; ===================================================
                        ; === Based on David Madole's UART detect utility ===
                        ; ===================================================
                        ;
                        insSEQ	equ	7BH
                        insREQ	equ	7AH
                        insB1	equ	34H
                        insBN1	equ	3CH
                        ;
                        UARTsetup:
   2882   9e            	ghi	re
   2883   fa fe         	ani	0feh
   2885   c2 29 02      	lbz	realUART	; baud constant 0000000x: real UART
                        ;
   2888   fb fe         	xri	0feh
   288a   c2 29 02      	lbz	realUART	; baud constant 1111111x: real UART
                        ;
   288d   f8 27 bf f8   	load	rf,SoftTxHigh	; patch addresses in soft UART Tx
   2891   13 af         
   2893   f8 27 bd f8   	load	rd,SoftTxLow
   2897   10 ad         
   2899   f8 27 bc f8   	load	rc,SoftTxStop
   289d   20 ac         
   289f   f8 7b         	ldi	insSEQ
   28a1   31 a5         	bq	QidlesHigh
                        QidlesLow:
   28a3   f8 7a         	ldi	insREQ
                        QidlesHigh:
   28a5   5f            	str	rf		; Tx 1 bit
   28a6   5c            	str	rc		; Tx stop bit (high)
   28a7   fb 01         	xri	insREQ XOR insSEQ
   28a9   5d            	str	rd		; Tx 0 bit
                        	 if	INFO
                        	pushd
                        	call	O_INMSG
                        	db	'Soft UART',cr,lf,'Tx on Q (pin idles ',0
                        	popd
                        	xri	insREQ
                        	bnz	qlow
                        	call	O_INMSG
                        	db	'high)',cr,lf,0
                        	br	afterq
                        qlow:	call	O_INMSG
                        	db	'low)',cr,lf,0
                        afterq:
                        ;
                        	call	O_INMSG
                        	db	'Rx on /EF',0
                        	 endi
   28aa   d4 2a 60      	call	searchrx
   28ad   c3 28 d1      	lbdf	unknownUART
                        ;
   28b0   ae            	plo	re
   28b1   f8 27 bf f8   	load	rf,SoftRxStart1	; patch addresses in soft UART Rx
   28b5   2b af         
   28b7   f8 27 bd f8   	load	rd,SoftRxStart2
   28bb   64 ad         
   28bd   f8 27 bc f8   	load	rc,SoftRxBit1
   28c1   32 ac         
   28c3   f8 27 bb f8   	load	rb,SoftRxBit2
   28c7   6b ab         
   28c9   8e            	glo	re
   28ca   5f            	str	rf
   28cb   5d            	str	rd
   28cc   fb 08         	xri	insB1 XOR insBN1 ; flip from Bx to BNx instruction
   28ce   5c            	str	rc		; or vice versa depending on idle
   28cf   5b            	str	rb		; state
                        	 if	INFO
                        	pushd
                        	ani	00000011b
                        	adi	'1'
                        	call	O_TYPE
                        	call	O_INMSG
                        	db	' (pin idles ',0
                        	popd
                        	ani	insB1 XOR insBN1
                        	bz	efIdlesHigh
                        	call	O_INMSG
                        	db	'low)',cr,lf,0
                        	retn
                        efIdlesHigh:
                        	call	O_INMSG
                        	db	'high)',cr,lf,0
                        	 endi
   28d0   d5            	retn
                        ;
                        unknownUART:
   28d1   d4 03 4b      	call	O_INMSG
   28d4   43 61 6e 27   	db	'Can',27h,'t figure out soft UART configuration',cr,lf,0
   28d8   74 20 66 69   
   28dc   67 75 72 65   
   28e0   20 6f 75 74   
   28e4   20 73 6f 66   
   28e8   74 20 55 41   
   28ec   52 54 20 63   
   28f0   6f 6e 66 69   
   28f4   67 75 72 61   
   28f8   74 69 6f 6e   
   28fc   0d 0a 00      
   28ff   c0 20 fd      	lbr	Exit
                        ;
                        realUART:
   2902   f8 26 bf f8   	load	rf,HardUARTlbr1	; with a real UART, we've got time
   2906   64 af         
   2908   f8 26 bd f8   	load	rd,HardUARTlbr2	; to spare between sending the last
   290c   79 ad         
   290e   f8 26         	ldi	high HardUARTlastChar
   2910   5f            	str	rf		; character in the block and reading
   2911   5d            	str	rd		; the ACK/NAK and (for block 0) the
   2912   1f            	inc	rf		; following CRC/NAK
   2913   1d            	inc	rd
   2914   f8 7b         	ldi	low HardUARTlastChar
   2916   5f            	str	rf
   2917   5d            	str	rd
   2918   d4 03 4b      	call	O_INMSG
   291b   52 65 61 6c   	db	'Real UART',cr,lf,0
   291f   20 55 41 52   
   2923   54 0d 0a 00   
   2927   d5            	retn
                         
                        ; Because the following code uses branch-on-EF instructions which
                        ; are only available in short branch form, it is organized in a
                        ; separate page of memory to ensure the branches do not end up
                        ; crossing a page boundary unexpectedly.
                        
                        	page
                        
                        ; The following lookup tables are used for decoding 1802 opcodes
                        ; so we know how to skip literal data bytes and recognize the
                        ; EF test instructions and those we will stop searching on. This
                        ; needs to be at the start of a page due to how its indexed.
                        ;
                        ;	0 - One byte instruction
                        ;	1 - Two byte instruction
                        ;	2 - Three byte instruction
                        ;	4 - Jump instruction
                        ;	8 - SEP other than R4
                        ; 16 - EF test instruction
                        
   2a00   00 00 00 10   opcodes:	db	0,0,0,low opcode3x,0,0,0,low opcode7x			; 0X-7X
   2a04   00 00 00 20   
   2a08   00 00 00 00   		db	0,0,0,0,low opcodecx,low opcodedx,0,low opcodefx	; 8X-FX
   2a0c   30 40 00 50   
                        
   2a10   01 01 01 01   opcode3x:	db	1,1,1,1,16,16,16,16,0,1,1,1,16,16,16,16	; 3X
   2a14   10 10 10 10   
   2a18   00 01 01 01   
   2a1c   10 10 10 10   
   2a20   00 00 00 00   opcode7x:	db	0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1		; 7X
   2a24   00 00 00 00   
   2a28   00 00 00 00   
   2a2c   01 01 00 01   
   2a30   04 02 02 02   opcodecx:	db	4,2,2,2,0,0,0,0,0,2,2,2,0,0,0,0		; CX
   2a34   00 00 00 00   
   2a38   00 02 02 02   
   2a3c   00 00 00 00   
   2a40   08 08 08 08   opcodedx:	db	8,8,8,8,2,8,8,8,8,8,8,8,8,8,8,8		; DX
   2a44   02 08 08 08   
   2a48   08 08 08 08   
   2a4c   08 08 08 08   
   2a50   00 00 00 00   opcodefx:	db	0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,1		; FX
   2a54   00 00 00 00   
   2a58   01 01 01 01   
   2a5c   01 01 00 01   
                        
                        ;
                        ; Determine the correct EF line by searching through the readkey
                        ; subroutine code looking for the first Bx/BNx instruction. This
                        ; tries to be intelligent by skipping literal bytes and only 
                        ; looking at opcodes so it is not fooled by data. It also follows
                        ; LBR opcodes but otherwise does a linear search. Stops at the 
                        ; first SEP instruction it sees that is not SEP R4.
                        ;
                        ; D will be 0 if the EF line can't be determined, otherwise it will
                        ; be the 1802 opcode that branches on an idle line condition.
                        ;
                        searchrx:
   2a60   f8 03 bf f8   	load	rf,O_READKEY
   2a64   36 af         
                        
   2a66   f8 2a         	ldi	high opcodes
   2a68   bd            	phi	rd
                        
   2a69   ed            	sex	rd
                        
   2a6a   30 78         	br	nextbyte
                        
                        jumpins:
   2a6c   1f            	inc	rf
                        
   2a6d   4f            	lda	rf		; make RF follow the LBR
   2a6e   ae            	plo	re
   2a6f   0f            	ldn	rf
   2a70   af            	plo	rf
   2a71   8e            	glo	re
   2a72   bf            	phi	rf
                        
   2a73   30 78         	br	nextbyte
                        
                        skip3ins:
   2a75   1f            	inc	rf
                        skip2ins:
   2a76   1f            	inc	rf
                        skip1ins:
   2a77   1f            	inc	rf
                        
                        nextbyte:
   2a78   0f            	ldn	rf
   2a79   f6            	shr
   2a7a   f6            	shr
   2a7b   f6            	shr
   2a7c   f6            	shr
   2a7d   ad            	plo	rd
                        
   2a7e   0d            	ldn	rd
   2a7f   32 77         	bz	skip1ins
                        
   2a81   0f            	ldn	rf
   2a82   fa 0f         	ani	0fh
   2a84   f1            	or
   2a85   ad            	plo	rd
                        
   2a86   0d            	ldn	rd			; 0
   2a87   32 77         	bz	skip1ins
                        
   2a89   f6            	shr				; 1
   2a8a   33 76         	bdf	skip2ins
                        
   2a8c   f6            	shr				; 2
   2a8d   33 75         	bdf	skip3ins
                        
   2a8f   f6            	shr				; 4
   2a90   33 6c         	bdf	jumpins
                        
   2a92   f6            	shr				; 8 terminate on SEP other than
   2a93   33 c7         	bdf	notfound		; SEP 4
                        
   2a95   0f            	ldn	rf			; 16
   2a96   fa 03         	ani	3
   2a98   ae            	plo	re
                        ;
                        ; Determine whether the EF line is inverted or not. This works by
                        ; looking at the level when the line is idle. Basically it watches
                        ; for the line to not change for a period of time and whatever 
                        ; level it's at is assumed to be the idle state. Note that this
                        ; code self-patches in the EF test instructions, kind of nasty but
                        ; sometimes on the 1802 you do what you have to do. This means it
                        ; can't go in ROM but if you are thinking about putting this in
                        ; ROM something else is going wrong anyway!
                        ;
   2a99   f8 2a         	ldi	high bef
   2a9b   bd            	phi	rd
                        
   2a9c   f8 b0         	ldi	low bef
   2a9e   ad            	plo	rd
   2a9f   8e            	glo	re
   2aa0   f9 34         	ori	34h
   2aa2   5d            	str	rd
                        
   2aa3   f8 bf         	ldi	low bnef
   2aa5   ad            	plo	rd
   2aa6   8e            	glo	re
   2aa7   f9 3c         	ori	3ch
   2aa9   5d            	str	rd
                        
                        negative:
   2aaa   f8 09         	ldi	9
   2aac   af            	plo	rf
   2aad   bf            	phi	rf
                        
                        negloop:
   2aae   2f            	dec	rf
   2aaf   9f            	ghi	rf
                        bef:
   2ab0   34 b9         	b1	positive
   2ab2   3a ae         	bnz	negloop
                        
   2ab4   f8 bf         	ldi	low bnef
   2ab6   ad            	plo	rd
   2ab7   0d            	ldn	rd
                        
   2ab8   d5            	retn
                        
                        positive:
   2ab9   f8 09         	ldi	9
   2abb   af            	plo	rf
   2abc   bf            	phi	rf
                        posloop:
   2abd   2f            	dec	rf
   2abe   9f            	ghi	rf
                        bnef:
   2abf   3c aa         	bn1	negative
   2ac1   3a bd         	bnz	posloop
                        
   2ac3   f8 b0         	ldi	low bef
   2ac5   ad            	plo	rd
   2ac6   0d            	ldn	rd
                        notfound:
   2ac7   d5            	retn
                        ; ===================================================
                        	 if	debug
                        ;
                        ; ***************************************************
                        ; ***** Debug output routine			*****
                        ; ***************************************************
                        TTYout:
                        	plo	re
                        	push	re
                        	push	rf
                        	push	rd
                        	load	rf,hexbuf
                        	ldi	0
                        	phi	rd
                        	glo	re
                        	plo	rd
                        	call	f_hexout2
                        	ldi	' '
                        	str	rf
                        	inc	rf
                        	ldi	0
                        	str	rf
                        	load	rf,hexbuf
                        	call	O_MSG
                        	load	rd,hexcount
                        	ldn	rd
                        	adi	1
                        	str	rd
                        	smi	16
                        	lbnz	NotEOL
                        	str	rd
                        	call	crlf
                        NotEOL:
                        	pop	rd
                        	pop	rf
                        	pop	re
                        	retn
                        hexbuf:	ds	4
                        hexcount:
                        	db	0
                        	retn
                        ;
                        	 else
                        ;
                        TTYout	equ	f_tty		; non debug output routine
                        ;
                        	 endi
                        ;
                        	page			; The CRC tables must be page aligned
                        ;
                        crcTableLow:
   2b00   00 21 42 63   	db	000h,021h,042h,063h,084h,0a5h,0c6h,0e7h
   2b04   84 a5 c6 e7   
   2b08   08 29 4a 6b   	db	008h,029h,04ah,06bh,08ch,0adh,0ceh,0efh
   2b0c   8c ad ce ef   
   2b10   31 10 73 52   	db	031h,010h,073h,052h,0b5h,094h,0f7h,0d6h
   2b14   b5 94 f7 d6   
   2b18   39 18 7b 5a   	db	039h,018h,07bh,05ah,0bdh,09ch,0ffh,0deh
   2b1c   bd 9c ff de   
   2b20   62 43 20 01   	db	062h,043h,020h,001h,0e6h,0c7h,0a4h,085h
   2b24   e6 c7 a4 85   
   2b28   6a 4b 28 09   	db	06ah,04bh,028h,009h,0eeh,0cfh,0ach,08dh
   2b2c   ee cf ac 8d   
   2b30   53 72 11 30   	db	053h,072h,011h,030h,0d7h,0f6h,095h,0b4h
   2b34   d7 f6 95 b4   
   2b38   5b 7a 19 38   	db	05bh,07ah,019h,038h,0dfh,0feh,09dh,0bch
   2b3c   df fe 9d bc   
   2b40   c4 e5 86 a7   	db	0c4h,0e5h,086h,0a7h,040h,061h,002h,023h
   2b44   40 61 02 23   
   2b48   cc ed 8e af   	db	0cch,0edh,08eh,0afh,048h,069h,00ah,02bh
   2b4c   48 69 0a 2b   
   2b50   f5 d4 b7 96   	db	0f5h,0d4h,0b7h,096h,071h,050h,033h,012h
   2b54   71 50 33 12   
   2b58   fd dc bf 9e   	db	0fdh,0dch,0bfh,09eh,079h,058h,03bh,01ah
   2b5c   79 58 3b 1a   
   2b60   a6 87 e4 c5   	db	0a6h,087h,0e4h,0c5h,022h,003h,060h,041h
   2b64   22 03 60 41   
   2b68   ae 8f ec cd   	db	0aeh,08fh,0ech,0cdh,02ah,00bh,068h,049h
   2b6c   2a 0b 68 49   
   2b70   97 b6 d5 f4   	db	097h,0b6h,0d5h,0f4h,013h,032h,051h,070h
   2b74   13 32 51 70   
   2b78   9f be dd fc   	db	09fh,0beh,0ddh,0fch,01bh,03ah,059h,078h
   2b7c   1b 3a 59 78   
   2b80   88 a9 ca eb   	db	088h,0a9h,0cah,0ebh,00ch,02dh,04eh,06fh
   2b84   0c 2d 4e 6f   
   2b88   80 a1 c2 e3   	db	080h,0a1h,0c2h,0e3h,004h,025h,046h,067h
   2b8c   04 25 46 67   
   2b90   b9 98 fb da   	db	0b9h,098h,0fbh,0dah,03dh,01ch,07fh,05eh
   2b94   3d 1c 7f 5e   
   2b98   b1 90 f3 d2   	db	0b1h,090h,0f3h,0d2h,035h,014h,077h,056h
   2b9c   35 14 77 56   
   2ba0   ea cb a8 89   	db	0eah,0cbh,0a8h,089h,06eh,04fh,02ch,00dh
   2ba4   6e 4f 2c 0d   
   2ba8   e2 c3 a0 81   	db	0e2h,0c3h,0a0h,081h,066h,047h,024h,005h
   2bac   66 47 24 05   
   2bb0   db fa 99 b8   	db	0dbh,0fah,099h,0b8h,05fh,07eh,01dh,03ch
   2bb4   5f 7e 1d 3c   
   2bb8   d3 f2 91 b0   	db	0d3h,0f2h,091h,0b0h,057h,076h,015h,034h
   2bbc   57 76 15 34   
   2bc0   4c 6d 0e 2f   	db	04ch,06dh,00eh,02fh,0c8h,0e9h,08ah,0abh
   2bc4   c8 e9 8a ab   
   2bc8   44 65 06 27   	db	044h,065h,006h,027h,0c0h,0e1h,082h,0a3h
   2bcc   c0 e1 82 a3   
   2bd0   7d 5c 3f 1e   	db	07dh,05ch,03fh,01eh,0f9h,0d8h,0bbh,09ah
   2bd4   f9 d8 bb 9a   
   2bd8   75 54 37 16   	db	075h,054h,037h,016h,0f1h,0d0h,0b3h,092h
   2bdc   f1 d0 b3 92   
   2be0   2e 0f 6c 4d   	db	02eh,00fh,06ch,04dh,0aah,08bh,0e8h,0c9h
   2be4   aa 8b e8 c9   
   2be8   26 07 64 45   	db	026h,007h,064h,045h,0a2h,083h,0e0h,0c1h
   2bec   a2 83 e0 c1   
   2bf0   1f 3e 5d 7c   	db	01fh,03eh,05dh,07ch,09bh,0bah,0d9h,0f8h
   2bf4   9b ba d9 f8   
   2bf8   17 36 55 74   	db	017h,036h,055h,074h,093h,0b2h,0d1h,0f0h
   2bfc   93 b2 d1 f0   
                        ;
                        crcTableHigh:
   2c00   00 10 20 30   	db	000h,010h,020h,030h,040h,050h,060h,070h
   2c04   40 50 60 70   
   2c08   81 91 a1 b1   	db	081h,091h,0a1h,0b1h,0c1h,0d1h,0e1h,0f1h
   2c0c   c1 d1 e1 f1   
   2c10   12 02 32 22   	db	012h,002h,032h,022h,052h,042h,072h,062h
   2c14   52 42 72 62   
   2c18   93 83 b3 a3   	db	093h,083h,0b3h,0a3h,0d3h,0c3h,0f3h,0e3h
   2c1c   d3 c3 f3 e3   
   2c20   24 34 04 14   	db	024h,034h,004h,014h,064h,074h,044h,054h
   2c24   64 74 44 54   
   2c28   a5 b5 85 95   	db	0a5h,0b5h,085h,095h,0e5h,0f5h,0c5h,0d5h
   2c2c   e5 f5 c5 d5   
   2c30   36 26 16 06   	db	036h,026h,016h,006h,076h,066h,056h,046h
   2c34   76 66 56 46   
   2c38   b7 a7 97 87   	db	0b7h,0a7h,097h,087h,0f7h,0e7h,0d7h,0c7h
   2c3c   f7 e7 d7 c7   
   2c40   48 58 68 78   	db	048h,058h,068h,078h,008h,018h,028h,038h
   2c44   08 18 28 38   
   2c48   c9 d9 e9 f9   	db	0c9h,0d9h,0e9h,0f9h,089h,099h,0a9h,0b9h
   2c4c   89 99 a9 b9   
   2c50   5a 4a 7a 6a   	db	05ah,04ah,07ah,06ah,01ah,00ah,03ah,02ah
   2c54   1a 0a 3a 2a   
   2c58   db cb fb eb   	db	0dbh,0cbh,0fbh,0ebh,09bh,08bh,0bbh,0abh
   2c5c   9b 8b bb ab   
   2c60   6c 7c 4c 5c   	db	06ch,07ch,04ch,05ch,02ch,03ch,00ch,01ch
   2c64   2c 3c 0c 1c   
   2c68   ed fd cd dd   	db	0edh,0fdh,0cdh,0ddh,0adh,0bdh,08dh,09dh
   2c6c   ad bd 8d 9d   
   2c70   7e 6e 5e 4e   	db	07eh,06eh,05eh,04eh,03eh,02eh,01eh,00eh
   2c74   3e 2e 1e 0e   
   2c78   ff ef df cf   	db	0ffh,0efh,0dfh,0cfh,0bfh,0afh,09fh,08fh
   2c7c   bf af 9f 8f   
   2c80   91 81 b1 a1   	db	091h,081h,0b1h,0a1h,0d1h,0c1h,0f1h,0e1h
   2c84   d1 c1 f1 e1   
   2c88   10 00 30 20   	db	010h,000h,030h,020h,050h,040h,070h,060h
   2c8c   50 40 70 60   
   2c90   83 93 a3 b3   	db	083h,093h,0a3h,0b3h,0c3h,0d3h,0e3h,0f3h
   2c94   c3 d3 e3 f3   
   2c98   02 12 22 32   	db	002h,012h,022h,032h,042h,052h,062h,072h
   2c9c   42 52 62 72   
   2ca0   b5 a5 95 85   	db	0b5h,0a5h,095h,085h,0f5h,0e5h,0d5h,0c5h
   2ca4   f5 e5 d5 c5   
   2ca8   34 24 14 04   	db	034h,024h,014h,004h,074h,064h,054h,044h
   2cac   74 64 54 44   
   2cb0   a7 b7 87 97   	db	0a7h,0b7h,087h,097h,0e7h,0f7h,0c7h,0d7h
   2cb4   e7 f7 c7 d7   
   2cb8   26 36 06 16   	db	026h,036h,006h,016h,066h,076h,046h,056h
   2cbc   66 76 46 56   
   2cc0   d9 c9 f9 e9   	db	0d9h,0c9h,0f9h,0e9h,099h,089h,0b9h,0a9h
   2cc4   99 89 b9 a9   
   2cc8   58 48 78 68   	db	058h,048h,078h,068h,018h,008h,038h,028h
   2ccc   18 08 38 28   
   2cd0   cb db eb fb   	db	0cbh,0dbh,0ebh,0fbh,08bh,09bh,0abh,0bbh
   2cd4   8b 9b ab bb   
   2cd8   4a 5a 6a 7a   	db	04ah,05ah,06ah,07ah,00ah,01ah,02ah,03ah
   2cdc   0a 1a 2a 3a   
   2ce0   fd ed dd cd   	db	0fdh,0edh,0ddh,0cdh,0bdh,0adh,09dh,08dh
   2ce4   bd ad 9d 8d   
   2ce8   7c 6c 5c 4c   	db	07ch,06ch,05ch,04ch,03ch,02ch,01ch,00ch
   2cec   3c 2c 1c 0c   
   2cf0   ef ff cf df   	db	0efh,0ffh,0cfh,0dfh,0afh,0bfh,08fh,09fh
   2cf4   af bf 8f 9f   
   2cf8   6e 7e 4e 5e   	db	06eh,07eh,04eh,05eh,02eh,03eh,00eh,01eh
   2cfc   2e 3e 0e 1e   
                        ;
                        CmdDta:		ds	512
                        SndDta:		ds	512
                        uint32_buf:	ds	UINT32_DIGITS+1	
                        		ds	128
                        localStack:	ds	1
                        saveStack:	ds	2
                        ;
                        cmdFilename:	ds	128
                        sndFilename:	ds	128
                        ;
                        DirBuffer:	ds	512
                        DirEntBuffer:	ds	32
                        ;
                        year:		ds	1
                        month:		ds	1
                        dom:		ds	1
                        hours:		ds	1
                        minutes:	ds	1
                        seconds:	ds	1
                        ;
                        epoch:		ds	4
                        ;
                        blkNum:		ds	1		; current block #
                        blkMode:	ds	1		; 0=checksum, 1=CRC
                        fileSize:	ds	4		; # bytes remaining in file
                        block0:		ds	128		; buffer for tx/rx
                        blockBuffer:	ds	1024		; 1k send data buffer
                        ;
                        endrom	equ	$
                        ;
                        	end
0006  ack           286d  add32bits     2272  B0loop1       0004  b_devBBSER
0002  b_devFLPY     0001  b_devIDE      0001  b_devNBREAD    0020  b_devNVR  
0010  b_devRTC      0008  b_devUART     2ab0  bef           ff00  BIOS      
2452  bitLoop       34b9  blkMode       34b8  blkNum        34be  block0    
2572  BlockACKed    353e  blockBuffer    2abf  bnef          0008  bs        
25b3  bsLoop        2006  Build         0018  can           259f  Cancel    
25a6  cancelLoop    2039  CmdDirOfs     2035  CmdDirSec     2d00  CmdDta    
202c  CmdFilDes     318e  cmdFilename    2186  CmdFileOpened    222c  copyDir   
2243  copyFileName    000d  cr            0043  crc           2499  CrcMode   
2c00  crcTableHigh    2b00  crcTableLow    27a8  crlf          0000  debug     
279e  delay         27a2  delay1        279d  delayX        25eb  DidntGetACK
328e  DirBuffer     348e  DirEntBuffer    34b0  dom           2415  domDone   
240d  domLoop       f800  EBIOS         393e  endrom        2259  eofdir    
0004  eot           34b4  epoch         0005  errdirnotempty    0001  errexists 
0003  errinvdir     0004  errisdir      0002  errnoffnd     0006  errnotexec
20fd  Exit          211f  Exit2         f830  f_astodt      f833  f_astotm  
ff5d  f_atoi        ff00  f_boot        ff42  f_bootide     f800  f_bread   
ff6c  f_brktest     f806  f_btest       f803  f_btype       ff33  f_div16   
ff2a  f_drive       f827  f_dttoas      ff6f  f_findtkn     ff57  f_freemem 
ff81  f_getdev      f815  f_gettod      ff45  f_hexin       ff48  f_hexout2 
ff4b  f_hexout4     f824  f_ideid       ff3c  f_ideread     ff36  f_idereset
f821  f_idesize     ff39  f_idewrite    ff7b  f_idnum       ff3f  f_initcall
ff66  f_inmsg       ff0f  f_input       ff69  f_inputl      ff63  f_intout  
ff78  f_isalnum     ff72  f_isalpha     ff75  f_ishex       ff5a  f_isnum   
ff7e  f_isterm      ff15  f_ltrim       ff1b  f_memcpy      ff54  f_minimon 
ff51  f_mover       ff09  f_msg         ff30  f_mul16       ff54  f_nbread  
f836  f_nvrcchk     f81b  f_rdnvr       ff21  f_rdsec       ff06  f_read    
f82d  f_rtctest     ff27  f_seek        ff24  f_seek0       ff2d  f_setbd   
f818  f_settod      ff12  f_strcmp      ff18  f_strcpy      f82a  f_tmtoas  
ff4e  f_tty         ff03  f_type        ff0c  f_typex       ff60  f_uintout 
f80c  f_uread       f812  f_usetbd      f80f  f_utest       f809  f_utype   
fff9  f_version     f81e  f_wrnvr       ff1e  f_wrtsec      0010  ff_archive
0001  ff_dir        0002  ff_exec       0008  ff_hide       0004  ff_write  
257a  FileDone      2575  FileDonePop    24e0  FileSendLoop    34ba  fileSize  
25d1  GetACK        25e7  GotACK        25cf  GotNAKorCRC    2692  HardAcked 
2683  HardAckedAction    267b  HardUARTlastChar    2664  HardUARTlbr1    2679  HardUARTlbr2
223c  hasTrailingSlash    34b1  hours         242c  hoursDone     2425  hoursLoop 
03f6  I_SERVE       0000  info          0034  insB1         003c  insBN1    
007a  insREQ        007b  insSEQ        21e1  isDirFile     27c5  itoa1     
2842  itoa2         2846  itoa3         2a6c  jumpins       0406  K_BDAY    
0405  K_BMONTH      0403  K_BUILD       0407  K_BYEAR       0470  K_CLKFREQ 
0476  K_DAY         0468  K_HEAP        0442  K_HIMEM       0478  K_HOUR    
0465  K_LOWMEM      0479  K_MINUTE      0475  K_MONTH       0467  K_RETVAL  
047b  K_SECDEN      047d  K_SECNUM      047a  K_SECOND      0400  K_VER     
0477  K_YEAR        000a  lf            2000  LoadAdr       318b  localStack
2839  loop1         34b2  minutes       243f  minutesDone    2437  minutesLoop
34af  month         2020  monthDays     23ec  monthLoop     2406  monthsDone
23ea  monthsLoop    2508  MoreToGo      0015  nak           24fa  NearingTheEnd
2aaa  negative      2aae  negloop       2781  nextBlock     2a78  nextbyte  
20b1  NextFile      20f4  NextFileName    23ff  noLeapYearChk    23ff  notFebruary
2ac7  notfound      23c5  notLeapYear    036c  O_ALLOC       0004  O_APPND   
035a  O_BOOT        0366  O_BRKTEST     0324  O_CHDIR       0300  O_CLDBOOT 
0312  O_CLOSE       0001  O_CREAT       0475  O_DATTIM      036f  O_DEALLOC 
0318  O_DELETE      0369  O_DEVCTRL     031e  O_EXEC        0342  O_EXECBIN 
034e  O_GETDEV      0351  O_GETTOD      0363  O_INITCALL    034b  O_INMSG   
0339  O_INPUT       0357  O_INPUTL      0348  O_KINIT       0375  O_MEMCTRL 
0321  O_MKDIR       0333  O_MSG         0306  O_OPEN        0315  O_OPENDIR 
033f  O_PRINT       033c  O_PRTSTAT     032a  O_RDLUMP      0309  O_READ    
0336  O_READKEY     031b  O_RENAME      0327  O_RMDIR       030f  O_SEEK    
0360  O_SETBD       0345  O_SETDEF      0354  O_SETTOD      0372  O_TERMCTRL
0002  O_TRUNC       0330  O_TYPE        030c  O_WRITE       032d  O_WRLUMP  
0303  O_WRMBOOT     2210  occupied      2a10  opcode3x      2a20  opcode7x  
2a30  opcodecx      2a40  opcodedx      2a50  opcodefx      2a00  opcodes   
2ab9  positive      2abd  posloop       2131  ProcCopyName    2125  ProcFile  
28a5  QidlesHigh    28a3  QidlesLow     0000  r0            0001  r1        
000a  r10           000b  r11           000c  r12           000d  r13       
000e  r14           000f  r15           0002  r2            0003  r3        
0004  r4            0005  r5            0006  r6            0007  r7        
0008  r8            0009  r9            000a  ra            000b  rb        
000c  rc            000d  rd            000e  re            2523  ReadBytes 
2723  readne        2902  realUART      2777  recvne2dn     2769  recvne2lp 
279b  recvne2lp0    276f  recvne2lp1    273e  recvnedn      2730  recvnelp  
2799  recvnelp0     2736  recvnelp1     25ff  ResendBlock    000f  rf        
249b  SaveMode      318c  saveStack     0004  scall         2a60  searchrx  
34b3  seconds       261a  Send128       2609  SendBlock     274e  SendBlockError
25ef  SendEOT       2263  SendFile      248d  SendFileError    261c  SendStart 
2666  SendWithChecksum    2645  SendWithCRC    2a77  skip1ins      2a76  skip2ins  
2a75  skip3ins      204c  SndDirOfs     2048  SndDirSec     2f00  SndDta    
203f  SndFilDes     320e  sndFilename    22c0  SndFileOpened    2744  SoftAckedAction
275c  SoftReadne2    2732  SoftRxBit1    276b  SoftRxBit2    272b  SoftRxStart1
2764  SoftRxStart2    2713  SoftTxHigh    2710  SoftTxLow     2720  SoftTxStop
2700  SoftUARTlastChar    0001  soh           0005  sret          2052  start     
207b  start2        0002  stx           27cc  tobcdlp1      27dd  tobcdlp2  
27e4  tobcdlp3      27ed  tobcdlp3a     2810  tobcdlp4      ff4e  TTYout    
2716  typect        270e  typelp        2882  UARTsetup     0020  UINT32_BITS
3100  uint32_buf    000a  UINT32_DIGITS    27af  uint32_out    2863  uint32outz
28d1  unknownUART    036a  V_DVEC        03fd  V_IVEC        25c3  WaitNAKorCRC
34ae  year          239f  yearLoop      23cd  yearsDone     258e  ZeroBlock0
2594  ZeroLoop      
