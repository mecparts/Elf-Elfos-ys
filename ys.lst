                        ; -------------------------------------------------------------------
                        ; -------------------------------------------------------------------
                        ; *** ys: send one or more files using YMODEM batch protocol
                        ; ***
                        ; *** Build #
                        ; ***  1: Proof of concept version
                        ; ***  2: First bug squashed: 256 & 512 byte files were sent 
                        ; ***     as 0 bytes
                        ; ***  3: Added file timestamp to block 0
                        ; ***  4: Inlined some Tx/Rx code to make it fast enough to
                        ; ***     catch the ACK & CRC/NAK at the end of a block send
                        ; *******************************************************************
                        ; *** This software is released to the public domain.		  ***
                        ; *** You have permission to use, modify, copy, and distribute	  ***
                        ; *** this software as you please.				  ***
                        ; *******************************************************************
                        ;
                        ; Register usage:
                        ;
                        ; System:
                        ;   r0   - Resesrved for DMA
                        ;   r1   - Reserved for interrupts
                        ;   r2   - Stack pointer
                        ;   r3   - Program counter
                        ;   r4   - SCALL program counter
                        ;   r5   - SRET program counter
                        ;   r6   - SCALL return address
                        ;   re.0 - SCALL overwrites with D
                        ;   re.1 - Baud rate constant
                        ;
                        ; Main program :
                        ;
                        ;   ra   - Command line pointer (on exec)
                        ;
                        ; All other registers are available for subroutines.
                        ;
                        	include	"bios.inc"
                        ; *******************************************************************
                        ; *** This software is copyright 2006 by Michael H Riley		***
                        ; *** You have permission to use, modify, copy, and distribute	***
                        ; *** this software so long as this copyright notice is retained. ***
                        ; *** This software may not be used in commercial applications	***
                        ; *** without express written permission from the author.	 ***
                        ; *******************************************************************
                        
                        ; f_getdev bit values
                        
                        b_devIDE	equ	00000001b	; IDE
                        b_devFLPY	equ	00000010b	; floppy
                        b_devBBSER	equ	00000100b	; Bit-banged serial
                        b_devUART	equ	00001000b	; UART
                        b_devRTC	equ	00010000b	; RTC
                        b_devNVR	equ	00100000b	; NVRAM
                        
                        #ifndef _IS_BIOS
                        
                        ; Define address for standard BIOS vectors
                        BIOS	equ	0ff00h
                        
                        ; Define address for extended BIOS vectors
                        EBIOS	equ	0f800h
                        
                        scall	equ	r4			; register for SCALL
                        sret	equ	r5			; register for SRET
                        
                        f_boot		equ	(BIOS+00h)	; boot from ide device
                        f_type		equ	(BIOS+03h)	; type 1 character to console
                        f_read		equ	(BIOS+06h)	; read 1 character from console
                        f_msg		equ	(BIOS+09h)	; type asciiz string to console
                        f_typex		equ	(BIOS+0ch)	; depricated, just returns now
                        f_input		equ	(BIOS+0fh)	; read asciiz from console
                        f_strcmp	equ	(BIOS+12h)	; compare 2 strings
                        f_ltrim		equ	(BIOS+15h)	; trim leading spaces
                        f_strcpy	equ	(BIOS+18h)	; copy an asciiz string
                        f_memcpy	equ	(BIOS+1bh)	; copy memory
                        f_wrtsec	equ	(BIOS+1eh)	; write floppy sector (depricated)
                        f_rdsec		equ	(BIOS+21h)	; read floppy sector (depricated)
                        f_seek0		equ	(BIOS+24h)	; floppy seek to track 0 (depricated)
                        f_seek		equ	(BIOS+27h)	; floopy track seek (depricated)
                        f_drive		equ	(BIOS+2ah)	; select floppy drive (depricated)
                        f_setbd		equ	(BIOS+2dh)	; set console baud rate
                        f_mul16		equ	(BIOS+30h)	; 16-bit multiply
                        f_div16		equ	(BIOS+33h)	; 16-bit division
                        f_idereset	equ	(BIOS+36h)	; reset ide device
                        f_idewrite	equ	(BIOS+39h)	; write ide sector
                        f_ideread	equ	(BIOS+3ch)	; read ide sector
                        f_initcall	equ	(BIOS+3fh)	; initialize R4 and R5
                        f_bootide	equ	(BIOS+42h)	; boot from ide device
                        f_hexin		equ	(BIOS+45h)	; convert ascii number to hex
                        f_hexout2	equ	(BIOS+48h)	; convert hex to 2-digit ascii
                        f_hexout4	equ	(BIOS+4bh)	; convert hex to 4-digit ascii
                        f_tty		equ	(BIOS+4eh)	; type character to console
                        f_mover		equ	(BIOS+51h)	; program relocator
                        f_minimon	equ	(BIOS+54h)	; mini monitor
                        f_freemem	equ	(BIOS+57h)	; determine memory size
                        f_isnum		equ	(BIOS+5ah)	; determine if D is numeric
                        f_atoi		equ	(BIOS+5dh)	; convert ascii to integer
                        f_uintout	equ	(BIOS+60h)	; convert unsigned integer to ascii
                        f_intout	equ	(BIOS+63h)	; convert signed integer to ascii
                        f_inmsg		equ	(BIOS+66h)	; type in-line message
                        f_inputl	equ	(BIOS+69h)	; read limited line from console
                        f_brktest	equ	(BIOS+6ch)	; check for serial break
                        f_findtkn	equ	(BIOS+6fh)	; find token in a token table
                        f_isalpha	equ	(BIOS+72h)	; determine if D is alphabetic
                        f_ishex		equ	(BIOS+75h)	; determine if D is hexadecimal
                        f_isalnum	equ	(BIOS+78h)	; determine if D is alpha or numeric
                        f_idnum		equ	(BIOS+7bh)	; determine type of ascii number
                        f_isterm	equ	(BIOS+7eh)	; determine if D is a termination char
                        f_getdev	equ	(BIOS+81h)	; get supported devices
                        
                        f_version	equ	(BIOS+0f9h)	; 3 bytes holding bios version number
                        
                        ; "Extended" BIOS vectors
                        
                        f_bread		equ	(EBIOS+00h)	; read from onboard serial port
                        f_btype		equ	(EBIOS+03h)	; write to onboard serial port
                        f_btest		equ	(EBIOS+06h)	; test onboard serial port
                        f_utype		equ	(EBIOS+09h)	; write to disk board UART
                        f_uread		equ	(EBIOS+0ch)	; read from disk board UART
                        f_utest		equ	(EBIOS+0fh)	; test disk board UART
                        f_usetbd	equ	(EBIOS+12h)	; set disk board UART baud rate and format
                        f_gettod	equ	(EBIOS+15h)	; read time of day clock
                        f_settod	equ	(EBIOS+18h)	; set time of day clock
                        f_rdnvr		equ	(EBIOS+1bh)	; read non volatile RAM
                        f_wrnvr		equ	(EBIOS+1eh)	; write non volatile RAM
                        f_idesize	equ	(EBIOS+21h)	; return size of attached IDE drive(s)
                        f_ideid		equ	(EBIOS+24h)	; return device data for IDE drive(s)
                        f_tmtoas	equ	(EBIOS+2ah)	; time to ASCII string
                        f_dttoas	equ	(EBIOS+27h)	; date to ASCII string
                        f_rtctest	equ	(EBIOS+2dh)	; test size and presence of RTC/NVR
                        f_astodt	equ	(EBIOS+30h)	; convert ASCII string to date
                        f_astotm	equ	(EBIOS+33h)	; convert ASCII string to time
                        f_nvrcchk	equ	(EBIOS+36h)	; compute NVR checksum
                        
                        #endif
                        
                        	include	"kernel.inc"
                        O_CLDBOOT: equ     0300h               ; jump to cold boot routine
                        O_WRMBOOT: equ     0303h               ; jump to warm boot routine
                        O_OPEN:    equ     0306h               ; open a file
                        O_READ:    equ     0309h               ; read from file
                        O_WRITE:   equ     030ch               ; write to file
                        O_SEEK:    equ     030fh               ; seek to file position
                        O_CLOSE:   equ     0312h               ; close file
                        O_OPENDIR: equ     0315h               ; open dir as a file
                        O_DELETE:  equ     0318h               ; delete a file
                        O_RENAME:  equ     031bh               ; rename a file
                        O_EXEC:    equ     031eh               ; execute an external program
                        O_MKDIR:   equ     0321h               ; make directory
                        O_CHDIR:   equ     0324h               ; change directory
                        O_RMDIR:   equ     0327h               ; remove directory
                        O_RDLUMP:  equ     032Ah               ; read LAT entry
                        O_WRLUMP:  equ     032Dh               ; write LAT entry
                        O_TYPE:    equ     0330h               ; passthrough for console output
                        O_MSG:     equ     0333h               ; passthrough for console output
                        O_READKEY: equ     0336h               ; passthrough for console input
                        O_INPUT:   equ     0339h               ; passthrough for console input
                        O_PRTSTAT: equ     033ch               ; printer status
                        O_PRINT:   equ     033fh               ; output to printer
                        O_EXECBIN: equ     0342h               ; execute from default directory
                        O_SETDEF:  equ     0345h               ; set/get default directory
                        O_KINIT:   equ     0348h               ; reserved - do not use!!!
                        O_INMSG:   equ     034bh               ; passthrough for console output
                        O_GETDEV:  equ     034eh               ; passthrough to f_getdef
                        O_GETTOD:  equ     0351h               ; passthrough to f_gettod
                        O_SETTOD:  equ     0354h               ; passthrough to f_settod
                        O_INPUTL:  equ     0357h               ; passthrough to f_inputl
                        O_BOOT:    equ     035ah               ; passthrough to f_boot
                        O_SETBD:   equ     0360h               ; passthrough to f_setbd
                        O_INITCALL: equ    0363h               ; passthrough to f_initcall
                        O_BRKTEST: equ     0366h               ; passthrough to f_brktest
                        O_DEVCTRL: equ     0369h               ; Hook for device control drivers
                        O_ALLOC:   equ     036ch               ; passthrough to alloc
                        O_DEALLOC: equ     036fh               ; passthrough to dealloc
                        O_TERMCTRL: equ    0372h               ; Hook for terminal control drivers
                        O_MEMCTRL: equ     0375h               ; Hook for memory control drivers
                        I_SERVE:   equ     03f6h               ; address of interrupt chain head
                        V_IVEC:    equ     03fdh               ; interrupt head
                        V_DVEC:    equ     036ah               ; device head
                        K_VER:     equ     0400h               ; kernel version number
                        K_BUILD:   equ     0403h               ; kernel build number
                        K_BMONTH:  equ     0405h               ; kernel build month
                        K_BDAY:    equ     0406h               ; kernel build day
                        K_BYEAR:   equ     0407h               ; kernel build month
                        K_HIMEM:   equ     0442h               ; high memory pointer
                        K_LOWMEM:  equ     0465h               ; lowest memory heap can use
                        K_RETVAL:  equ     0467h               ; D on program exit
                        K_HEAP:    equ     0468h               ; heap pointer
                        K_CLKFREQ: equ     0470h               ; system clock frequency
                        K_MONTH:   equ     0475h               ; date/time
                        K_DAY:     equ     0476h
                        K_YEAR:    equ     0477h
                        K_HOUR:    equ     0478h
                        K_MINUTE:  equ     0479h
                        K_SECOND:  equ     047ah
                        K_SECDEN:  equ     047bh
                        K_SECNUM:  equ     047dh
                        ;
                        ;O_HIMEM:   equ     0442h               ; himem value
                        O_DATTIM:  equ     0475h               ; date/time block
                        ;
                        errexists: equ     1
                        errnoffnd: equ     2
                        errinvdir: equ     3
                        errisdir:  equ     4
                        errdirnotempty: equ   5
                        errnotexec:     equ   6
                        ;
                        O_CREAT	equ	00000001b
                        O_TRUNC	equ	00000010b
                        O_APPND	equ	00000100b
                        
                        ;	
                        debug	equ	0
                        ;
                        ; ***************************************************
                        ; ***** Constants				*****
                        ; ***************************************************
                        cr	equ	'M'-'@'
                        lf	equ	'J'-'@'
                        bs	equ	'H'-'@'
                        ;
                        soh	equ	'A'-'@'		; 128 byte packet header
                        stx	equ	'B'-'@'		; 1K byte packet header
                        eot	equ	'D'-'@'		; end of file transfer marker
                        ack	equ	'F'-'@'		; Acknowledge (good packet)
                        nak	equ	'U'-'@'		; Negative acknowledge (bad packet)
                        can	equ	'X'-'@'		; cancel transfer
                        crc	equ	'C'		; use CRC rather than checksum
                        ;
                        ; ***************************************************
                        ; ***** This block is the Execution header for	*****
                        ; ***** a stand-alone program. It begins 6	*****
                        ; *****bytes before the program start.		*****
                        ; ***************************************************
                        LoadAdr	equ	2000h
                        	org	LoadAdr-6	; Header starts at 01ffah
   1ffa   20 00         	dw	LoadAdr
   1ffc   09 00         	dw	EndRom-LoadAdr
   1ffe   20 00         	dw	LoadAdr
                        ;
                        ; ***************************************************
                        ; ***** Code start				*****
                        ; ***************************************************
   2000   30 4a         	br	Start
                        ;
                        ; ***************************************************
                        ; ***** Program header				*****
                        ; ***************************************************
   2002   87 1f 07 e5   	date
   2006   00 04         Build:	dw	4		; build number
   2008   62 69 74 20   	db	'bit banged UART on Q/EF2, inverted',0
   200c   62 61 6e 67   
   2010   65 64 20 55   
   2014   41 52 54 20   
   2018   6f 6e 20 51   
   201c   2f 45 46 32   
   2020   2c 20 69 6e   
   2024   76 65 72 74   
   2028   65 64 00      
                        ;
                        ;
                        monthDays:
   202b   1f 1c 1f 1e   	db	31,28,31,30,31,30,31,31,30,31,30,31
   202f   1f 1e 1f 1f   
   2033   1e 1f 1e 1f   
                        ;
   2037   00 00 00 00   FilDes:	db	0,0,0,0		; current file offset
   203b   29 00         	dw	Dta		; DTA
   203d   00 00         	dw	0		; eof
   203f   00            	db	0		; flags
   2040   00 00 00 00   sector:	db	0,0,0,0		; dir sector
   2044   00 00         dirofs:	dw	0		; dir offset
   2046   00 00 00 00   	db	0,0,0,0		; current sector in DTA
                        ;
                        ; ***************************************************
                        ; ***** Main program				*****
                        ; ***************************************************
                        start:	
   204a   86 73 96 73   	push	r6		; save Elf/OS's return address on its stack
   204e   f8 2b bf f8   	load	rf,saveStack	; save Elf/OS's stack
   2052   8c af         
   2054   92            	ghi	r2
   2055   5f            	str	rf
   2056   1f            	inc	rf
   2057   82            	glo	r2
   2058   5f            	str	rf
   2059   f8 2b b2 f8   	load	r2,localStack	; use our own stack
   205d   8b a2         
   205f   9e            	ghi	re		; turn off console echo
   2060   fa fe         	ani	11111110b
   2062   be            	phi	re
                        ;
   2063   d4 20 c8      	call	NextFileName	; point to first file name
   2066   ca 20 92      	lbnz	NextFile	; and go send it
   2069   d4 03 4b      	call	O_INMSG		; otherwise display usage message
   206c   55 73 61 67   	db	'Usage:	ys filename [filename...]',cr,lf,0
   2070   65 3a 09 79   
   2074   73 20 66 69   
   2078   6c 65 6e 61   
   207c   6d 65 20 5b   
   2080   66 69 6c 65   
   2084   6e 61 6d 65   
   2088   2e 2e 2e 5d   
   208c   0d 0a 00      
   208f   c0 20 d1      	lbr	Exit		; and return to os
                        NextFile:
   2092   d4 20 e5      	call	SendFile	; send next file
   2095   d4 20 c8      	call	NextFileName	; point to next file name in cmd tail
   2098   ca 20 92      	lbnz	NextFile	; loop for next file
   209b   d4 24 1b      	call	WaitNAKorCRC
   209e   f8 2d bf f8   	load	rf,blknum
   20a2   98 af         
   20a4   f8 00         	ldi	0
   20a6   5f            	str	rf
   20a7   d4 23 e6      	call	ZeroBlock0	; send zero filled block 0 to finish up
                        	 if	debug=0
   20aa   f8 25 bf f8   	load	rf,AckedAction
   20ae   44 af         
   20b0   f8 81         	ldi	low nextBlock
   20b2   5f            	str	rf
                        	 endi
   20b3   f8 2d bf f8   	load	rf,block0
   20b7   9e af         
   20b9   f8 00 bc f8   	load	rc,128
   20bd   80 ac         
   20bf   f8 0a         	ldi	10
   20c1   a8            	plo	r8
   20c2   d4 24 60      	call	SendBlock
   20c5   c0 20 d1      	lbr	Exit		; and return to os
                        ;
                        ; ***************************************************
                        ; ***** NextFilename: advance RA to the next	*****
                        ; ***** non space character			*****
                        ; ***************************************************
                        NextFileName:
   20c8   4a            	lda	ra		; move past any spaces
   20c9   ff 20         	smi	' '
   20cb   c2 20 c8      	lbz	NextFileName
   20ce   2a            	dec	ra		; move back to non-space character
   20cf   0a            	ldn	ra		; get byte
   20d0   d5            	retn
                        ;
                        ; ***************************************************
                        ; ***** Exit: return to Elf/OS, restoring OS	*****
                        ; *****       stack and R6 contents		*****
                        ; ***************************************************
                        Exit:
   20d1   9e            	ghi	re		; restore console echo
   20d2   f9 01         	ori	00000001b
   20d4   be            	phi	re
   20d5   f8 2b bf f8   	load	rf,saveStack	; restore Elf/OS's stack
   20d9   8c af         
   20db   4f            	lda	rf
   20dc   b2            	phi	r2
   20dd   0f            	ldn	rf
   20de   a2            	plo	r2
   20df   60 72 b6 f0   	pop	r6		; restore Elf/OS's return address
   20e3   a6            
   20e4   d5            	retn			; return to Elf/OS
                        ;
                        ; ***************************************************
                        ; ***** Send file: send a single file	  	*****
                        ; ***** RA: points to file name			*****
                        ; ***************************************************
                        SendFile:
   20e5   d4 23 e6      	call	ZeroBlock0
   20e8   f8 2d bd f8   	load	rd,block0	; copy filename to block
   20ec   9e ad         
                        B0loop1:
   20ee   4a            	lda	ra		; look for first less <= space
   20ef   5d            	str	rd
   20f0   1d            	inc	rd
   20f1   ff 21         	smi	' '+1
   20f3   c3 20 ee      	lbdf	B0loop1
   20f6   2a            	dec	ra
   20f7   2d            	dec	rd
   20f8   f8 00         	ldi	0		; zero terminate filename
   20fa   5d            	str	rd
   20fb   1d            	inc	rd
   20fc   8d 73 9d 73   	push	rd		; save block ptr
   2100   f8 20 bd f8   	load	rd,fildes	; get file descriptor
   2104   37 ad         
   2106   f8 2d bf f8   	load	rf,block0
   210a   9e af         
   210c   f8 04         	ldi	O_APPND		; flags for open, append
   210e   a7            	plo	r7
   210f   d4 03 06      	call	O_OPEN		; attempt to open file to determine size
   2112   cb 21 3c      	lbnf	B0opened	; jump if file was opened
   2115   d4 03 4b      	call	O_INMSG
   2118   43 6f 75 6c   	db	'Couldn',27,'t open file: ',0
   211c   64 6e 1b 74   
   2120   20 6f 70 65   
   2124   6e 20 66 69   
   2128   6c 65 3a 20   
   212c   00            
   212d   f8 2d bf f8   	load	rf,block0
   2131   9e af         
   2133   d4 03 33      	call	O_MSG		; display it
   2136   d4 25 a8      	call	crlf
   2139   c0 20 d1      	lbr	Exit		; and return to os
                        B0opened:
   213c   f8 20 bd f8   	load	rd,fildes
   2140   37 ad         
   2142   f8 2d bf f8   	load	rf,fileSize
   2146   9a af         
   2148   4d            	lda	rd		; put 32 bit offset into
   2149   b7            	phi	r7		; R7:R8 and fileSize
   214a   5f            	str	rf
   214b   1f            	inc	rf
                        ;
   214c   4d            	lda	rd
   214d   a7            	plo	r7
   214e   5f            	str	rf
   214f   1f            	inc	rf
                        ;
   2150   4d            	lda	rd
   2151   b8            	phi	r8
   2152   5f            	str	rf
   2153   1f            	inc	rf
                        ;
   2154   0d            	ldn	rd
   2155   a8            	plo	r8
   2156   5f            	str	rf
                        ;
   2157   2d            	dec	rd		; restore descriptor
   2158   2d            	dec	rd
   2159   2d            	dec	rd
                        ;
   215a   87 73 97 73   	push	r7
   215e   88 73 98 73   	push	r8
                        ;
   2162   f8 00 b8 f8   	load	r8,0
   2166   00 a8         
   2168   f8 00 b7 f8   	load	r7,0
   216c   00 a7         
   216e   f8 20 bd f8   	load	rd,fildes
   2172   37 ad         
   2174   f8 00 bc f8   	load	rc,0		; rewind file to start
   2178   00 ac         
   217a   d4 03 0f      	call	O_SEEK
                        ;
   217d   60 72 b8 f0   	pop	r8
   2181   a8            
   2182   60 72 b7 f0   	pop	r7
   2186   a7            
   2187   60 72 bf f0   	pop	rf		; restore block ptr
   218b   af            
   218c   d4 25 af      	call	uint32_out	; convert number to ascii
   218f   f8 20         	ldi	' '		; finish file size with space	
   2191   5f            	str	rf
   2192   1f            	inc	rf
                        ;
   2193   8a 73 9a 73   	push	ra
   2197   8f 73 9f 73   	push	rf
   219b   f8 e0         	ldi	0e0h		; lba mode
   219d   b8            	phi	r8
   219e   f8 20 bf f8   	load	rf,sector+1	; point to dir sector in FILDES
   21a2   41 af         
   21a4   4f            	lda	rf		; retrieve sector
   21a5   a8            	plo	r8
   21a6   4f            	lda	rf
   21a7   b7            	phi	r7
   21a8   4f            	lda	rf
   21a9   a7            	plo	r7
   21aa   f8 2b bf f8   	load	rf,dirbuf	; where to load sector
   21ae   8e af         
   21b0   d4 ff 3c      	call	f_ideread	; call bios to read the sector
                        ;
   21b3   f8 20 bf f8   	load	rf,dirofs+1	; need dirent offset
   21b7   45 af         
   21b9   0f            	ldn	rf
   21ba   fc 07         	adi	7		; point to date block
   21bc   aa            	plo	ra
   21bd   2f            	dec	rf
   21be   0f            	ldn	rf
   21bf   7c 00         	adci	0		; propagate carry
   21c1   ba            	phi	ra		; r7 now points to date block
   21c2   8a            	glo	ra		; now point to correct spot in sector buffer
   21c3   fc 8e         	adi	low dirbuf
   21c5   aa            	plo	ra
   21c6   9a            	ghi	ra
   21c7   7c 2b         	adci	high dirbuf
   21c9   ba            	phi	ra
                        ;
   21ca   f8 2d bf f8   	load	rf,year
   21ce   8e af         
   21d0   4a            	lda	ra		; get year/month
   21d1   f6            	shr			; shift high month bit into DF
   21d2   0a            	ldn	ra		; get low bits of month
   21d3   76            	shrc			; shift high bit in
   21d4   f6            	shr			; then shift into position
   21d5   f6            	shr
   21d6   f6            	shr
   21d7   f6            	shr
   21d8   1f            	inc	rf
   21d9   5f            	str	rf		; store month
   21da   1f            	inc	rf		; point to day storage
   21db   0a            	ldn	ra		; recover day
   21dc   fa 1f         	ani	31		; mask for day
   21de   5f            	str	rf		; store day
   21df   2f            	dec	rf
   21e0   2f            	dec	rf		; point back to year offset storage
   21e1   2a            	dec	ra		; point back to year
   21e2   4a            	lda	ra		; get year
   21e3   f6            	shr			; shift out high bit of month
   21e4   5f            	str	rf		; store year offset from 1972
   21e5   1f            	inc	rf
   21e6   1f            	inc	rf
   21e7   1f            	inc	rf		; point to hours storage
   21e8   1a            	inc	ra		; point to time
   21e9   0a            	ldn	ra		; retrieve hours
   21ea   f6            	shr			; shift to proper position
   21eb   f6            	shr
   21ec   f6            	shr
   21ed   5f            	str	rf		; store hours
   21ee   1f            	inc	rf		; point to minutes storage
   21ef   4a            	lda	ra		; get minutes
   21f0   fa 07         	ani	07h		; strip out hours
   21f2   fe            	shl			; shift to needed spot
   21f3   fe            	shl
   21f4   fe            	shl
   21f5   52            	str	r2		; save for combination
   21f6   0a            	ldn	ra		; get low bits of minutes
   21f7   f6            	shr			; shift into position
   21f8   f6            	shr
   21f9   f6            	shr
   21fa   f6            	shr
   21fb   f6            	shr
   21fc   f1            	or			; combine with high bites
   21fd   5f            	str	rf		; store minutes
   21fe   1f            	inc	rf		; point to seconds storage
   21ff   0a            	ldn	ra		; get seconds
   2200   fa 1f         	ani	1fh		; strip minutes out
   2202   fe            	shl			; multiply by 2
   2203   5f            	str	rf		; store seconds	
                        ;
   2204   f8 2d bf f8   	load	rf,year		; point back to year
   2208   8e af         
   220a   f8 03 b7 f8   	load	r7,03c2h	; number of seconds
   220e   c2 a7         
   2210   f8 67 b8 f8   	load	r8,6700h	; from Jan 1 1970 to Jan 1 1972
   2214   00 a8         
   2216   0f            	ldn	rf		; year offset from 1972
   2217   a9            	plo	r9
   2218   f8 00         	ldi	0
   221a   b9            	phi	r9		; leap year counter
                        yearLoop:
   221b   89            	glo	r9
   221c   32 49         	bz	yearsDone
   221e   f8 01 ba f8   	load	ra,01e1h	; seconds in a year
   2222   e1 aa         
   2224   f8 33 bb f8   	load	rb,3380h
   2228   80 ab         
   222a   d4 26 6d      	call	add32bits
   222d   99            	ghi	r9
   222e   fa 03         	ani	00000011b
   2230   3a 41         	bnz	notLeapYear
   2232   f8 00 ba f8   	load	ra,0001h	; seconds in the leap day
   2236   01 aa         
   2238   f8 51 bb f8   	load	rb,5180h	; (86400)
   223c   80 ab         
   223e   d4 26 6d      	call	add32bits
                        notLeapYear:
   2241   99            	ghi	r9
   2242   29            	dec	r9
   2243   fc 01         	adi	1
   2245   b9            	phi	r9
   2246   c0 22 1b      	lbr	yearLoop
                        yearsDone:
   2249   f8 00 ba f8   	load	ra,0001h	; seconds in a day
   224d   01 aa         
   224f   f8 51 bb f8   	load	rb,5180h	; (86400)
   2253   80 ab         
   2255   4f            	lda	rf		; re-get year
   2256   fa 03         	ani	00000011b	; rc.1 will be 0 if leap year
   2258   bc            	phi	rc		; 
   2259   4f            	lda	rf		; month # (1-12)
   225a   ff 01         	smi	1
   225c   32 80         	bz	monthsDone
   225e   ac            	plo	rc		; rc.0 is month # -1
   225f   f8 20 bd f8   	load	rd,monthDays
   2263   2b ad         
                        monthsLoop:
   2265   4d            	lda	rd
   2266   a9            	plo	r9		; rb.0 is # days in month
                        monthLoop:
   2267   d4 26 6d      	call	add32bits	; add a day's worth of seconds
   226a   29            	dec	r9		; decrement days left in month
   226b   89            	glo	r9
   226c   ca 22 67      	lbnz	monthLoop
   226f   9c            	ghi	rc		; leap year?
   2270   3a 7a         	bnz	noLeapYearChk
   2272   8d            	glo	rd		; test for February
   2273   ff 2d         	smi	low monthDays+2
   2275   3a 7a         	bnz	notFebruary
   2277   d4 26 6d      	call	add32bits	; add in another day in Feb in leap year	
                        noLeapYearChk:
                        notFebruary:
   227a   8c            	glo	rc
   227b   ff 01         	smi	1
   227d   ac            	plo	rc
   227e   3a 65         	bnz	monthsLoop
                        monthsDone:
   2280   4f            	lda	rf		; day of month
   2281   ff 01         	smi	1
   2283   32 8d         	bz	domDone
   2285   a9            	plo	r9
                        domLoop:
   2286   d4 26 6d      	call	add32bits
   2289   29            	dec	r9
   228a   89            	glo	r9
   228b   3a 86         	bnz	domLoop
                        domDone:
   228d   f8 00 ba f8   	load	ra,0
   2291   00 aa         
   2293   f8 0e bb f8   	load	rb,3600		; seconds in an hour
   2297   10 ab         
   2299   4f            	lda	rf
   229a   32 a4         	bz	hoursDone
   229c   a9            	plo	r9
                        hoursLoop:
   229d   d4 26 6d      	call	add32bits
   22a0   29            	dec	r9
   22a1   89            	glo	r9
   22a2   3a 9d         	bnz	hoursLoop
                        hoursDone:
   22a4   f8 00 bb f8   	load	rb,60		; seconds in a minute
   22a8   3c ab         
   22aa   4f            	lda	rf
   22ab   c2 22 b7      	lbz	minutesDone
   22ae   a9            	plo	r9
                        minutesLoop:
   22af   d4 26 6d      	call	add32bits
   22b2   29            	dec	r9
   22b3   89            	glo	r9
   22b4   ca 22 af      	lbnz	minutesLoop
                        minutesDone:
   22b7   0f            	ldn	rf		; get seconds
   22b8   ab            	plo	rb
   22b9   d4 26 6d      	call	add32bits
                        ;
   22bc   60 72 bf f0   	pop	rf		; restore block 0 ptr
   22c0   af            
   22c1   f8 0c         	ldi	'0' shr 2	; convert r7:r8 to octal number
   22c3   b9            	phi	r9		; and add to block 0 string
   22c4   f8 02         	ldi	2		; 2 bits on first digit
   22c6   a9            	plo	r9
   22c7   f8 0b         	ldi	11		; 11 digits in a 32 bit number
   22c9   aa            	plo	ra
                        bitLoop:
   22ca   88            	glo	r8
   22cb   fe            	shl
   22cc   a8            	plo	r8
   22cd   98            	ghi	r8
   22ce   7e            	shlc
   22cf   b8            	phi	r8
   22d0   87            	glo	r7
   22d1   7e            	shlc
   22d2   a7            	plo	r7
   22d3   97            	ghi	r7
   22d4   7e            	shlc
   22d5   b7            	phi	r7
   22d6   99            	ghi	r9
   22d7   7e            	shlc
   22d8   29            	dec	r9
   22d9   b9            	phi	r9
   22da   89            	glo	r9
   22db   3a ca         	bnz	bitLoop
   22dd   99            	ghi	r9
   22de   5f            	str	rf
   22df   1f            	inc	rf
   22e0   f8 06         	ldi	'0' shr 3	; next octal digit setup
   22e2   b9            	phi	r9
   22e3   f8 03         	ldi	3		; 3 bits for remaining digits
   22e5   a9            	plo	r9
   22e6   2a            	dec	ra
   22e7   8a            	glo	ra
   22e8   3a ca         	bnz	bitLoop
                        ;
   22ea   60 72 ba f0   	pop	ra
   22ee   aa            
                        ;
   22ef   f8 20         	ldi	' '		; finish timestamp with space	
   22f1   5f            	str	rf
   22f2   1f            	inc	rf
   22f3   f8 30         	ldi	'0'		; default file mode to 0
   22f5   5f            	str	rf
   22f6   5f            	str	rf
                        ;
   22f7   d4 24 1b      	call	WaitNAKorCRC
   22fa   ff 43         	smi	crc
   22fc   c2 23 10      	lbz	CrcMode
   22ff   ff d2         	smi	nak-crc
   2301   c2 23 12      	lbz	SaveMode
                        SendFileError:
   2304   f8 20 bd f8   	load	rd,fildes
   2308   37 ad         
   230a   d4 03 12      	call	O_CLOSE
   230d   ff 00         	smi	0		; DF=1, error
   230f   d5            	retn
                        CrcMode:
   2310   f8 01         	ldi	1
                        SaveMode:
   2312   a7            	plo	r7
   2313   f8 2d bf f8   	load	rf,blkMode
   2317   99 af         
   2319   87            	glo	r7
   231a   5f            	str	rf
                        ;
                        	 if	debug=0
   231b   f8 25 bf f8   	load	rf,AckedAction
   231f   44 af         
   2321   f8 5c         	ldi	low readne2
   2323   5f            	str	rf
                        	 endi
   2324   f8 2d bf f8   	load	rf,blkNum
   2328   98 af         
   232a   f8 00         	ldi	0
   232c   5f            	str	rf
   232d   f8 2d bf f8   	load	rf,block0
   2331   9e af         
   2333   f8 00 bc f8   	load	rc,128
   2337   80 ac         
   2339   f8 0a         	ldi	10
   233b   a8            	plo	r8
   233c   d4 24 60      	call	SendBlock	; send file block 0
   233f   c3 23 04      	lbdf	SendFileError
                        ;
                        	 if	debug
                        	pushd
                        	call	crlf
                        	load	rf,hexcount
                        	ldi	0
                        	str	rf
                        	popd
                        	 endif
                        ;
   2342   ff 43         	smi	crc
   2344   32 4a         	bz	fileSendLoop
   2346   ff d2         	smi	nak-crc
   2348   3a 04         	bnz	SendFileError
                        ;
                        FileSendLoop:
   234a   f8 2d bf f8   	load	rf,fileSize
   234e   9a af         
   2350   f8 04 bc f8   	load	rc,1024		; assume we've got at least 1K
   2354   00 ac         
   2356   4f            	lda	rf		; left to send
   2357   ca 23 72      	lbnz	MoreToGo
   235a   4f            	lda	rf
   235b   ca 23 72      	lbnz	MoreToGo
   235e   0f            	ldn	rf
   235f   ff 04         	smi	high 1024
   2361   c3 23 72      	lbdf	MoreToGo	; jump if >= 1K left to go
                        NearingTheEnd:
   2364   f8 00 bc f8   	load	rc,128		; switch to 128 byte sectors
   2368   80 ac         
   236a   4f            	lda	rf
   236b   ca 23 72      	lbnz	MoreToGo
   236e   0f            	ldn	rf
   236f   c2 23 d2      	lbz	FileDone
                        MoreToGo:
   2372   8c 73 9c 73   	push	rc
   2376   f8 20 bd f8   	load	rd,fildes
   237a   37 ad         
   237c   f8 2e bf f8   	load	rf,blockBuffer
   2380   1e af         
   2382   d4 03 09      	call	O_READ
   2385   8c            	glo	rc
   2386   ca 23 8d      	lbnz	ReadBytes
   2389   9c            	ghi	rc
   238a   c2 23 d2      	lbz	FileDone
                        ReadBytes:
   238d   f8 2d bf f8   	load	rf,fileSize+3	; LSB
   2391   9d af         
                        ;
   2393   8c            	glo	rc		; decrement fileSize by
   2394   52            	str	r2		; # bytes read
   2395   0f            	ldn	rf
   2396   f7            	sm
   2397   5f            	str	rf
                        ;
   2398   2f            	dec	rf
   2399   9c            	ghi	rc
   239a   52            	str	r2
   239b   0f            	ldn	rf
   239c   77            	smb
   239d   5f            	str	rf
                        ;
   239e   2f            	dec	rf
   239f   0f            	ldn	rf
   23a0   7d 00         	sdbi	0
   23a2   5f            	str	rf
                        ;
   23a3   2f            	dec	rf
   23a4   0f            	ldn	rf
   23a5   7d 00         	sdbi	0
   23a7   5f            	str	rf
                        ;
   23a8   60 72 bc f0   	pop	rc		; retrieve block size
   23ac   ac            
                        	 if	debug=0
   23ad   f8 25 bf f8   	load	rf,AckedAction
   23b1   44 af         
   23b3   f8 81         	ldi	low nextBlock
   23b5   5f            	str	rf
                        	 endi
   23b6   f8 2e bf f8   	load	rf,blockBuffer
   23ba   1e af         
   23bc   f8 0a         	ldi	10
   23be   a8            	plo	r8
   23bf   d4 24 60      	call	SendBlock
   23c2   c3 23 04      	lbdf	SendFileError
   23c5   ff 06         	smi	ack
   23c7   32 cf         	bz	BlockACKed
   23c9   d4 23 f7      	call	Cancel
   23cc   c0 23 04      	lbr	SendFileError
                        BlockACKed:
   23cf   c0 23 4a      	lbr	fileSendLoop
                        FileDone:
   23d2   d4 24 47      	call	SendEOT		; signal file done and get response
   23d5   ff 06         	smi	ack		; ACK'd?
   23d7   ca 23 04      	lbnz	SendFileError
   23da   f8 20 bd f8   	load	rd,fildes
   23de   37 ad         
   23e0   d4 03 12      	call	O_CLOSE
   23e3   fc 00         	adi	0		; DF=0, no error
   23e5   d5            	retn			; all done!
                        ;
                        ; ***************************************************
                        ; ***** ZeroBlock0: zeroes block 0		*****
                        ; ***************************************************
                        ZeroBlock0:
   23e6   f8 2d bf f8   	load	rf,block0
   23ea   9e af         
                        ZeroLoop:
   23ec   f8 00         	ldi	0
   23ee   5f            	str	rf
   23ef   1f            	inc	rf
   23f0   8f            	glo	rf
   23f1   ff 1e         	smi	low (block0+128)
   23f3   ca 23 ec      	lbnz	ZeroLoop
   23f6   d5            	retn
                        ;
                        ; ***************************************************
                        ; ***** Cancel: send 8 CANs followed by 8 BSs	*****
                        ; ***************************************************
                        Cancel:
   23f7   87 73 97 73   	push	r7
   23fb   f8 08         	ldi	8
   23fd   a7            	plo	r7
                        cancelLoop:
   23fe   f8 18         	ldi	can
   2400   d4 ff 4e      	call	TTYout		; send CAN (^X) 8 times
   2403   27            	dec	r7
   2404   87            	glo	r7
   2405   ca 23 fe      	lbnz	cancelLoop
   2408   f8 08         	ldi	8
   240a   a7            	plo	r7
                        bsLoop:
   240b   f8 08         	ldi	bs		; send BS (^H) 8 times
   240d   d4 ff 4e      	call	TTYout
   2410   27            	dec	r7
   2411   87            	glo	r7
   2412   ca 24 0b      	lbnz	bsLoop
   2415   60 72 b7 f0   	pop	r7
   2419   a7            
   241a   d5            	retn
                        ;
                        ; ***************************************************
                        ; ***** WaitNAKorCRC: wait for CRC or NAK char	*****
                        ; ***************************************************
                        WaitNAKorCRC:
                        	 if	debug
                        	ldi	crc
                        	 else	
   241b   d4 ff 06      	call	f_read
   241e   ae            	plo	re
   241f   ff 43         	smi	crc
   2421   32 27         	bz	GotNAKorCRC
   2423   ff d2         	smi	nak-crc
   2425   3a 1b         	bnz	WaitNAKorCRC
                        GotNAKorCRC:
   2427   8e            	glo	re
                        	 endi
   2428   d5            	retn
                        ;
                        ; ***************************************************
                        ; ***** GetACK: wait for ACK/NAK or CAN	char	*****
                        ; ***************************************************
                        GetACK:
                        	 if	debug
                        	ldi	ack
                        	 else
   2429   d4 ff 06      	call	f_read		; read response to block sent
                        	 endi
   242c   ae            	plo	re
   242d   ff 06         	smi	ack
   242f   c2 24 3f      	lbz	GotACK		; ACK'd, all good
   2432   ff 0f         	smi	nak-ack
   2434   c2 24 43      	lbz	DidntGetACK	; NAK'd, probably have to resend
   2437   ff 03         	smi	can-nak
   2439   c2 24 43      	lbz	DidntGetACK	; CAN'd, terminating transfer
   243c   c0 24 29      	lbr	GetACK
                        GotACK:
   243f   8e            	glo	re
   2440   fc 00         	adi	0		; DF = 0, ACKed
   2442   d5            	retn
                        DidntGetACK:
   2443   8e            	glo	re
   2444   ff 00         	smi	0		; DF = 1, not ACKed
   2446   d5            	retn
                        ;
                        ; ***************************************************
                        ; ***** SendEOT: send EOT, wait for ACK		*****
                        ; ***************************************************
                        SendEOT:
   2447   f8 04         	ldi	eot
   2449   d4 ff 4e      	call	TTYout		; send EOT (^D)
                        	 if	debug
                        	call	crlf
                        	push	rf
                        	load	rf,hexcount
                        	ldi	0
                        	str	rf
                        	pop	rf
                        	 else
   244c   d4 ff 06      	call	f_read
   244f   ff 06         	smi	ack		; wait for ACK (^F)
   2451   3a 47         	bnz	SendEOT
                        	 endi
   2453   f8 06         	ldi	ack
   2455   d5            	retn
                        ;
                        ; *******************************************
                        ; ***** Send file block	  		*****
                        ; ***** RF - pointer to block		*****
                        ; ***** RC - Block length		*****
                        ; ***** R8 - # retries			*****
                        ; *******************************************
                        ResendBlock:
   2456   60 72 bf f0   	pop	rf
   245a   af            
   245b   60 72 bc f0   	pop	rc
   245f   ac            
                        SendBlock:
   2460   8c 73 9c 73   	push	rc
   2464   8f 73 9f 73   	push	rf
   2468   9c            	ghi	rc		; 1K or 128b block?
   2469   c2 24 71      	lbz	Send128
   246c   f8 02         	ldi	stx		; 1K
   246e   c0 24 73      	lbr	SendStart
                        Send128:
   2471   f8 01         	ldi	soh		; 128b
                        SendStart:
   2473   d4 ff 4e      	call	TTYout		; SOH/STK
   2476   f8 2d bd f8   	load	rd,blkNum
   247a   98 ad         
   247c   0d            	ldn	rd
   247d   d4 ff 4e      	call	TTYout		; block #
   2480   0d            	ldn	rd
   2481   fd ff         	sdi	255
   2483   d4 ff 4e      	call	TTYout		; NOT block #
                        ;
   2486   f8 27         	ldi	high crcTableLow
   2488   b9            	phi	r9
   2489   f8 28         	ldi	high crcTableHigh
   248b   bb            	phi	rb
                        ;
   248c   f8 00 b7 f8   	load	r7,0
   2490   00 a7         
   2492   f8 2d bd f8   	load	rd,blkMode
   2496   99 ad         
   2498   0d            	ldn	rd		; 0=checksum, 1=CRC
   2499   c2 24 bb      	lbz	SendWithChecksum
                        ;
                        SendWithCRC:
   249c   0f            	ldn	rf
   249d   d4 ff 4e      	call	TTYout		; send data byte
   24a0   4f            	lda	rf		; retrieve again and advance ptr
                        ;
   24a1   52            	str	r2
   24a2   97            	ghi	r7		; j = (crc >> 8) ^ byte
   24a3   f3            	xor
   24a4   a9            	plo	r9
   24a5   ab            	plo	rb
                        ;
   24a6   87            	glo	r7		; crc = (crc << 8) ^ table[j]
   24a7   eb            	sex	rb
   24a8   f3            	xor
   24a9   e2            	sex	r2
   24aa   b7            	phi	r7
   24ab   09            	ldn	r9
   24ac   a7            	plo	r7
                        ;
   24ad   2c            	dec	rc		; loop while data bytes
   24ae   9c            	ghi	rc		; left to send
   24af   3a 9c         	bnz	SendWithCRC
   24b1   8c            	glo	rc
   24b2   3a 9c         	bnz	SendWithCRC
                        ;
   24b4   97            	ghi	r7		; send hi byte of CRC
   24b5   d4 ff 4e      	call	TTYout
   24b8   c0 25 00      	lbr	DoLastChar
                        ;
                        SendWithChecksum:
   24bb   4f            	lda	rf
   24bc   52            	str	r2
   24bd   87            	glo	r7
   24be   f4            	add
   24bf   a7            	plo	r7
   24c0   02            	ldn	r2
   24c1   d4 ff 4e      	call	TTYout		; send data byte
   24c4   2c            	dec	rc
   24c5   9c            	ghi	rc
   24c6   ca 24 bb      	lbnz	SendWithChecksum
   24c9   8c            	glo	rc
   24ca   ca 24 bb      	lbnz	SendWithChecksum
   24cd   c0 25 00      	lbr	DoLastChar
                        ;
                        	page
                        ;
                        ; BIOS calls weren't quite fast enough to catch the ACK and CRC/NAK
                        ; at the end of a block 0 send. They did manage just the ACK at the end
                        ; of a normal block, most of the time. So, reluctantly, I've had to
                        ; inline the bit banged UART code. I've got some ideas about auto
                        ; patching this to match the machine configuration, but it's all in
                        ; my head at the moment.
                        ;
                        DoLastChar:
                        	 if debug
                        	glo	r7
                        	call	ttyout
                        	load	rf,blknum
                        	ldn	rf
                        	adi	1
                        	str	rf
                        	load	rf,hexcount
                        	ldi	0
                        	str	rf
                        	call	O_INMSG
                        	db	'acked',cr,lf,0
                        	pop	rf
                        	pop	rc
                        	ldi	ack
                        	adi	0
                        	retn
                        	 else
   2500   f8 09         	ldi	9		; 9 bits to send
   2502   af            	plo	rf
   2503   f8 25 bd f8   	load	rd,delay	; point RD to delay routine
   2507   9e ad         
   2509   dd            	sep	rd
   250a   dd            	sep	rd
   250b   f8 00         	ldi	0
   250d   f6            	shr
   250e   33 13         typelp:	bdf	typenb		; jump if no bit
   2510   7a            	req			; set output
   2511   30 16         	br	typect
   2513   7b            typenb:	seq			; reset output
   2514   30 16         	br	typect
   2516   dd            typect:	sep	rd		; perform bit delay
   2517   e2            	sex	r2
   2518   e2            	sex	r2
   2519   87            	glo	r7
   251a   76            	shrc
   251b   a7            	plo	r7
   251c   2f            	dec	rf
   251d   8f            	glo	rf
   251e   3a 0e         	bnz	typelp
   2520   7b            	seq			; set stop bits
   2521   dd            	sep	rd		; wait half the pulse width
   2522   dd            	sep	rd		; wait another half the pulse width
                        readne:
   2523   f8 09         	ldi	9		; 8 bits to receive
   2525   af            	plo	rf
   2526   9e            	ghi	re		; first delay is half bit size
   2527   bf            	phi	rf
   2528   f6            	shr
   2529   f6            	shr
   252a   be            	phi	re
   252b   3d 2b         	bn2	$		; wait for transmission
   252d   dd            	sep	rd		; wait half the pulse width
   252e   9f            	ghi	rf		; recover baud constant
   252f   be            	phi	re
                        recvnelp:
   2530   9f            	ghi	rf
   2531   f6            	shr			; shift right
   2532   35 99         	b2	recvnelp0	; jump if zero bi
   2534   f9 80         	ori	128		; set bit
                        recvnelp1:
   2536   bf            	phi	rf
   2537   dd            	sep	rd		; perform bit delay
   2538   2f            	dec	rf		; decrement bit count
   2539   c4            	nop
   253a   c4            	nop
   253b   8f            	glo	rf		; check for zero
   253c   3a 30         	bnz	recvnelp	; loop if not
                        recvnedn:
   253e   dd            	sep	rd
   253f   9f            	ghi	rf		; get character
   2540   ae            	plo	re
                        
   2541   ff 06         	smi	ack
                        AckedAction equ	$+1
   2543   32 5c         	bz	readne2		; block ACK'd
   2545   ff 0f         	smi	nak-ack
   2547   3a 4e         	bnz	SendBlockError
   2549   28            	dec	r8		; block NAK'd
   254a   88            	glo	r8		; resend if any retries left
   254b   ca 24 56      	lbnz	ResendBlock
                        SendBlockError:
   254e   60 72 bf f0   	pop	rf
   2552   af            
   2553   60 72 bc f0   	pop	rc
   2557   ac            
   2558   8e            	glo	re
   2559   ff 00         	smi	0		; DF = 1, error
   255b   d5            	retn
                        readne2:
   255c   f8 09         	ldi	9		; 8 bits to receive
   255e   af            	plo	rf
   255f   9e            	ghi	re		; first delay is half bit size
   2560   bf            	phi	rf
   2561   f6            	shr
   2562   f6            	shr
   2563   be            	phi	re
   2564   3d 64         	bn2	$		; wait for transmission
   2566   dd            	sep	rd		; wait half the pulse width
   2567   9f            	ghi	rf		; recover baud constant
   2568   be            	phi	re
                        recvne2lp:
   2569   9f            	ghi	rf
   256a   f6            	shr			; shift right
   256b   35 9b         	b2	recvne2lp0	; jump if zero bi
   256d   f9 80         	ori	128		; set bit
                        recvne2lp1:
   256f   bf            	phi	rf
   2570   dd            	sep	rd		; perform bit delay
   2571   2f            	dec	rf		; decrement bit count
   2572   c4            	nop
   2573   c4            	nop
   2574   8f            	glo	rf		; check for zero
   2575   3a 69         	bnz	recvne2lp	; loop if not
                        recvne2dn:
   2577   9f            	ghi	rf		; get character
   2578   ae            	plo	re
   2579   ff 43         	smi	crc
   257b   32 81         	bz	nextBlock
   257d   ff d2         	smi	nak-crc
   257f   3a 4e         	bnz	SendBlockError
                        nextBlock:
   2581   f8 2d bf f8   	load	rf,blkNum
   2585   98 af         
   2587   0f            	ldn	rf
   2588   fc 01         	adi	1
   258a   5f            	str	rf
   258b   60 72 bf f0   	pop	rf
   258f   af            
   2590   60 72 bc f0   	pop	rc
   2594   ac            
   2595   8e            	glo	re
   2596   fc 00         	adi	0		; DF = 0, ok
   2598   d5            	retn
                        recvnelp0:
   2599   30 36         	br	recvnelp1	; equalize between 0 and 1
                        recvne2lp0:
   259b   30 6f         	br	recvne2lp1	; equalize between 0 and 1
                        ;
   259d   d3            delayX:	sep	r3
   259e   9e            delay:	ghi	re		; get baud constant
   259f   f6            	shr			; remove echo flag
   25a0   ae            	plo	re		; put into counter
   25a1   e2            	sex	r2		; waste a cycle
   25a2   2e            delay1:	dec	re		; decrement counter
   25a3   8e            	glo	re		; get count
   25a4   32 9d         	bz	delayX		; return if zero
   25a6   30 a2         	br	delay1		; otherwise keep going
                        	 endi
                        ;
                        ; ***************************************************
                        ; ***** Start a new line on the terminal	*****
                        ; ***************************************************
                        crlf:
   25a8   d4 03 4b      	call	O_INMSG
   25ab   0d 0a 00      	db	cr,lf,0
   25ae   d5            	retn
                        ;
                        ; ***************************************************
                        ; ***** Convert 32-bit unsigned int to ASCII	*****
                        ; ***** using the double-dabble algorithm	*****
                        ; ***** (AKA shift and add 3)			*****
                        ; ***** R7:R8 - 32-bit integer			*****
                        ; ***** RF - destination buffer	pointer		*****
                        ; ***************************************************
                        UINT32_DIGITS	EQU	10	; maximum of 10 digits in result
                        UINT32_BITS	EQU	32	; how many bits did you THINK there'd be???
                        
                        uint32_out:
   25af   8d 73 9d 73   	push	rd		; save consumed registers
   25b3   89 73 99 73   	push	r9
   25b7   88 73 98 73   	push	r8
   25bb   87 73 97 73   	push	r7
   25bf   f8 2b bd f8   	load	rd,uint32_buf	; RD is output buffer
   25c3   00 ad         
                        itoa1:	
   25c5   8d 73 9d 73   	push	rd		; save buffer pointer
   25c9   f8 0a         	ldi	UINT32_DIGITS	; clear out BCD buffer
   25cb   ae            	plo	re
                        tobcdlp1:
   25cc   f8 00         	ldi	0
   25ce   5d            	str	rd		; store into answer
   25cf   1d            	inc	rd
   25d0   2e            	dec	re		; decrement count
   25d1   8e            	glo	re
   25d2   ca 25 cc      	lbnz	tobcdlp1	; loop until done
   25d5   60 72 bd f0   	pop	rd		; recover buffer pointer
   25d9   ad            
   25da   f8 20         	ldi	UINT32_BITS	; 32 bits to process
   25dc   a9            	plo	r9
                        tobcdlp2:
   25dd   f8 0a         	ldi	UINT32_DIGITS	; process all 10 digits
   25df   ae            	plo	re		; for digits >= 5
   25e0   8d 73 9d 73   	push	rd		; save buffer pointer
                        tobcdlp3:
   25e4   0d            	ldn	rd		; get byte
   25e5   ff 05         	smi	5		; need to see if 5 or greater
   25e7   cb 25 ed      	lbnf	tobcdlp3a	; jump if not
   25ea   fc 08         	adi	5+3		; add 3 to original number
   25ec   5d            	str	rd		; and put it back
                        tobcdlp3a:
   25ed   1d            	inc	rd		; point to next cell
   25ee   2e            	dec	re		; decrement cell count
   25ef   8e            	glo	re		; retrieve count
   25f0   ca 25 e4      	lbnz	tobcdlp3	; loop back if not done
                        	
   25f3   88            	glo	r8		; shift 32 bit binary number
   25f4   fe            	shl			; 1 bit left
   25f5   a8            	plo	r8
   25f6   98            	ghi	r8
   25f7   7e            	shlc
   25f8   b8            	phi	r8
   25f9   87            	glo	r7
   25fa   7e            	shlc
   25fb   a7            	plo	r7
   25fc   97            	ghi	r7
   25fd   7e            	shlc
   25fe   b7            	phi	r7
                        	
   25ff   7e            	shlc			; now shift result to bit 3
   2600   fe            	shl
   2601   fe            	shl
   2602   fe            	shl
   2603   5d            	str	rd
   2604   60 72 bd f0   	pop	rd		; recover address
   2608   ad            
   2609   8d 73 9d 73   	push	rd		; save address again
   260d   f8 0a         	ldi	UINT32_DIGITS	; 10 BCD digits to process
   260f   ae            	plo	re
                        tobcdlp4:
   2610   4d            	lda	rd		; get current cell
   2611   52            	str	r2		; save it
   2612   0d            	ldn	rd		; get next cell
   2613   f6            	shr			; shift bit 3 into df
   2614   f6            	shr
   2615   f6            	shr
   2616   f6            	shr
   2617   02            	ldn	r2		; recover value for current cell
   2618   7e            	shlc			; shift with new bit
   2619   fa 0f         	ani	00001111b	; keep only bottom 4 bits
   261b   2d            	dec	rd		; point back
   261c   5d            	str	rd		; store value
   261d   1d            	inc	rd		; and move to next cell
   261e   2e            	dec	re		; decrement count
   261f   8e            	glo	re		; see if done
   2620   ca 26 10      	lbnz	tobcdlp4	; jump if not
   2623   60 72 bd f0   	pop	rd		; recover address
   2627   ad            
   2628   29            	dec	r9		; decrement bit count
   2629   89            	glo	r9		; see if done
   262a   ca 25 dd      	lbnz	tobcdlp2	; loop until done
                        ;
   262d   f8 2b bd f8   	load	rd,uint32_buf
   2631   00 ad         
   2633   f8 0a         	ldi	UINT32_DIGITS
   2635   a8            	plo	r8
   2636   f8 09         	ldi	UINT32_DIGITS-1	; max 9 leading zeros
   2638   b8            	phi	r8
   2639   4d            loop1:	lda	rd
   263a   c2 26 63      	lbz	uint32outz	; check leading zeros
   263d   52            	str	r2		; save for a moment
   263e   f8 00         	ldi	0		; signal no more leading zeros
   2640   b8            	phi	r8
   2641   02            	ldn	r2		; recover character
   2642   fc 30         itoa2:	adi	'0'
   2644   5f            	str	rf		; store into output buffer
   2645   1f            	inc	rf
   2646   28            itoa3:	dec	r8
   2647   88            	glo	r8
   2648   ca 26 39      	lbnz	loop1
   264b   f8 00         	ldi	0		; place terminator in destination
   264d   5f            	str	rf
   264e   60 72 b7 f0   	pop	r7
   2652   a7            
   2653   60 72 b8 f0   	pop	r8		; recover consumed registers
   2657   a8            
   2658   60 72 b9 f0   	pop	r9
   265c   a9            
   265d   60 72 bd f0   	pop	rd
   2661   ad            
   2662   d5            	retn			; return to caller
                        
                        uint32outz:
   2663   98            	ghi	r8		; see if leading have been used up
   2664   c2 26 42      	lbz	itoa2		; jump if so
   2667   ff 01         	smi	1		; decrement count
   2669   b8            	phi	r8
   266a   c0 26 46      	lbr	itoa3		; and loop for next character
                        ;
                        ; ***************************************************
                        ; ***** add32bits: r7:r8 = r7:r8 + ra:rb	*****
                        ; ***************************************************
                        add32bits:
   266d   8b            	glo	rb
   266e   52            	str	r2
   266f   88            	glo	r8
   2670   f4            	add
   2671   a8            	plo	r8
   2672   9b            	ghi	rb
   2673   52            	str	r2
   2674   98            	ghi	r8
   2675   74            	adc
   2676   b8            	phi	r8
   2677   8a            	glo	ra
   2678   52            	str	r2
   2679   87            	glo	r7
   267a   74            	adc
   267b   a7            	plo	r7
   267c   9a            	ghi	ra
   267d   52            	str	r2
   267e   97            	ghi	r7
   267f   74            	adc
   2680   b7            	phi	r7
   2681   d5            	retn
                        ;
                        	 if	debug
                        ;
                        ; ***************************************************
                        ; ***** Debug output routine			*****
                        ; ***************************************************
                        TTYout:
                        	plo	re
                        	push	re
                        	push	rf
                        	push	rd
                        	load	rf,hexbuf
                        	ldi	0
                        	phi	rd
                        	glo	re
                        	plo	rd
                        	call	f_hexout2
                        	ldi	' '
                        	str	rf
                        	inc	rf
                        	ldi	0
                        	str	rf
                        	load	rf,hexbuf
                        	call	O_MSG
                        	load	rd,hexcount
                        	ldn	rd
                        	adi	1
                        	str	rd
                        	smi	16
                        	lbnz	NotEOL
                        	str	rd
                        	call	crlf
                        NotEOL:
                        	pop	rd
                        	pop	rf
                        	pop	re
                        	retn
                        hexbuf:	ds	4
                        hexcount:
                        	db	0
                        	retn
                        ;
                        	 else
                        ;
                        TTYout	equ	f_tty		; non debug output routine
                        ;
                        	 endi
                        ;
                        	page			; The CRC tables must be page aligned
                        ;
                        crcTableLow:
   2700   00 21 42 63   	db	000h,021h,042h,063h,084h,0a5h,0c6h,0e7h
   2704   84 a5 c6 e7   
   2708   08 29 4a 6b   	db	008h,029h,04ah,06bh,08ch,0adh,0ceh,0efh
   270c   8c ad ce ef   
   2710   31 10 73 52   	db	031h,010h,073h,052h,0b5h,094h,0f7h,0d6h
   2714   b5 94 f7 d6   
   2718   39 18 7b 5a   	db	039h,018h,07bh,05ah,0bdh,09ch,0ffh,0deh
   271c   bd 9c ff de   
   2720   62 43 20 01   	db	062h,043h,020h,001h,0e6h,0c7h,0a4h,085h
   2724   e6 c7 a4 85   
   2728   6a 4b 28 09   	db	06ah,04bh,028h,009h,0eeh,0cfh,0ach,08dh
   272c   ee cf ac 8d   
   2730   53 72 11 30   	db	053h,072h,011h,030h,0d7h,0f6h,095h,0b4h
   2734   d7 f6 95 b4   
   2738   5b 7a 19 38   	db	05bh,07ah,019h,038h,0dfh,0feh,09dh,0bch
   273c   df fe 9d bc   
   2740   c4 e5 86 a7   	db	0c4h,0e5h,086h,0a7h,040h,061h,002h,023h
   2744   40 61 02 23   
   2748   cc ed 8e af   	db	0cch,0edh,08eh,0afh,048h,069h,00ah,02bh
   274c   48 69 0a 2b   
   2750   f5 d4 b7 96   	db	0f5h,0d4h,0b7h,096h,071h,050h,033h,012h
   2754   71 50 33 12   
   2758   fd dc bf 9e   	db	0fdh,0dch,0bfh,09eh,079h,058h,03bh,01ah
   275c   79 58 3b 1a   
   2760   a6 87 e4 c5   	db	0a6h,087h,0e4h,0c5h,022h,003h,060h,041h
   2764   22 03 60 41   
   2768   ae 8f ec cd   	db	0aeh,08fh,0ech,0cdh,02ah,00bh,068h,049h
   276c   2a 0b 68 49   
   2770   97 b6 d5 f4   	db	097h,0b6h,0d5h,0f4h,013h,032h,051h,070h
   2774   13 32 51 70   
   2778   9f be dd fc   	db	09fh,0beh,0ddh,0fch,01bh,03ah,059h,078h
   277c   1b 3a 59 78   
   2780   88 a9 ca eb   	db	088h,0a9h,0cah,0ebh,00ch,02dh,04eh,06fh
   2784   0c 2d 4e 6f   
   2788   80 a1 c2 e3   	db	080h,0a1h,0c2h,0e3h,004h,025h,046h,067h
   278c   04 25 46 67   
   2790   b9 98 fb da   	db	0b9h,098h,0fbh,0dah,03dh,01ch,07fh,05eh
   2794   3d 1c 7f 5e   
   2798   b1 90 f3 d2   	db	0b1h,090h,0f3h,0d2h,035h,014h,077h,056h
   279c   35 14 77 56   
   27a0   ea cb a8 89   	db	0eah,0cbh,0a8h,089h,06eh,04fh,02ch,00dh
   27a4   6e 4f 2c 0d   
   27a8   e2 c3 a0 81   	db	0e2h,0c3h,0a0h,081h,066h,047h,024h,005h
   27ac   66 47 24 05   
   27b0   db fa 99 b8   	db	0dbh,0fah,099h,0b8h,05fh,07eh,01dh,03ch
   27b4   5f 7e 1d 3c   
   27b8   d3 f2 91 b0   	db	0d3h,0f2h,091h,0b0h,057h,076h,015h,034h
   27bc   57 76 15 34   
   27c0   4c 6d 0e 2f   	db	04ch,06dh,00eh,02fh,0c8h,0e9h,08ah,0abh
   27c4   c8 e9 8a ab   
   27c8   44 65 06 27   	db	044h,065h,006h,027h,0c0h,0e1h,082h,0a3h
   27cc   c0 e1 82 a3   
   27d0   7d 5c 3f 1e   	db	07dh,05ch,03fh,01eh,0f9h,0d8h,0bbh,09ah
   27d4   f9 d8 bb 9a   
   27d8   75 54 37 16   	db	075h,054h,037h,016h,0f1h,0d0h,0b3h,092h
   27dc   f1 d0 b3 92   
   27e0   2e 0f 6c 4d   	db	02eh,00fh,06ch,04dh,0aah,08bh,0e8h,0c9h
   27e4   aa 8b e8 c9   
   27e8   26 07 64 45   	db	026h,007h,064h,045h,0a2h,083h,0e0h,0c1h
   27ec   a2 83 e0 c1   
   27f0   1f 3e 5d 7c   	db	01fh,03eh,05dh,07ch,09bh,0bah,0d9h,0f8h
   27f4   9b ba d9 f8   
   27f8   17 36 55 74   	db	017h,036h,055h,074h,093h,0b2h,0d1h,0f0h
   27fc   93 b2 d1 f0   
                        ;
                        crcTableHigh:
   2800   00 10 20 30   	db	000h,010h,020h,030h,040h,050h,060h,070h
   2804   40 50 60 70   
   2808   81 91 a1 b1   	db	081h,091h,0a1h,0b1h,0c1h,0d1h,0e1h,0f1h
   280c   c1 d1 e1 f1   
   2810   12 02 32 22   	db	012h,002h,032h,022h,052h,042h,072h,062h
   2814   52 42 72 62   
   2818   93 83 b3 a3   	db	093h,083h,0b3h,0a3h,0d3h,0c3h,0f3h,0e3h
   281c   d3 c3 f3 e3   
   2820   24 34 04 14   	db	024h,034h,004h,014h,064h,074h,044h,054h
   2824   64 74 44 54   
   2828   a5 b5 85 95   	db	0a5h,0b5h,085h,095h,0e5h,0f5h,0c5h,0d5h
   282c   e5 f5 c5 d5   
   2830   36 26 16 06   	db	036h,026h,016h,006h,076h,066h,056h,046h
   2834   76 66 56 46   
   2838   b7 a7 97 87   	db	0b7h,0a7h,097h,087h,0f7h,0e7h,0d7h,0c7h
   283c   f7 e7 d7 c7   
   2840   48 58 68 78   	db	048h,058h,068h,078h,008h,018h,028h,038h
   2844   08 18 28 38   
   2848   c9 d9 e9 f9   	db	0c9h,0d9h,0e9h,0f9h,089h,099h,0a9h,0b9h
   284c   89 99 a9 b9   
   2850   5a 4a 7a 6a   	db	05ah,04ah,07ah,06ah,01ah,00ah,03ah,02ah
   2854   1a 0a 3a 2a   
   2858   db cb fb eb   	db	0dbh,0cbh,0fbh,0ebh,09bh,08bh,0bbh,0abh
   285c   9b 8b bb ab   
   2860   6c 7c 4c 5c   	db	06ch,07ch,04ch,05ch,02ch,03ch,00ch,01ch
   2864   2c 3c 0c 1c   
   2868   ed fd cd dd   	db	0edh,0fdh,0cdh,0ddh,0adh,0bdh,08dh,09dh
   286c   ad bd 8d 9d   
   2870   7e 6e 5e 4e   	db	07eh,06eh,05eh,04eh,03eh,02eh,01eh,00eh
   2874   3e 2e 1e 0e   
   2878   ff ef df cf   	db	0ffh,0efh,0dfh,0cfh,0bfh,0afh,09fh,08fh
   287c   bf af 9f 8f   
   2880   91 81 b1 a1   	db	091h,081h,0b1h,0a1h,0d1h,0c1h,0f1h,0e1h
   2884   d1 c1 f1 e1   
   2888   10 00 30 20   	db	010h,000h,030h,020h,050h,040h,070h,060h
   288c   50 40 70 60   
   2890   83 93 a3 b3   	db	083h,093h,0a3h,0b3h,0c3h,0d3h,0e3h,0f3h
   2894   c3 d3 e3 f3   
   2898   02 12 22 32   	db	002h,012h,022h,032h,042h,052h,062h,072h
   289c   42 52 62 72   
   28a0   b5 a5 95 85   	db	0b5h,0a5h,095h,085h,0f5h,0e5h,0d5h,0c5h
   28a4   f5 e5 d5 c5   
   28a8   34 24 14 04   	db	034h,024h,014h,004h,074h,064h,054h,044h
   28ac   74 64 54 44   
   28b0   a7 b7 87 97   	db	0a7h,0b7h,087h,097h,0e7h,0f7h,0c7h,0d7h
   28b4   e7 f7 c7 d7   
   28b8   26 36 06 16   	db	026h,036h,006h,016h,066h,076h,046h,056h
   28bc   66 76 46 56   
   28c0   d9 c9 f9 e9   	db	0d9h,0c9h,0f9h,0e9h,099h,089h,0b9h,0a9h
   28c4   99 89 b9 a9   
   28c8   58 48 78 68   	db	058h,048h,078h,068h,018h,008h,038h,028h
   28cc   18 08 38 28   
   28d0   cb db eb fb   	db	0cbh,0dbh,0ebh,0fbh,08bh,09bh,0abh,0bbh
   28d4   8b 9b ab bb   
   28d8   4a 5a 6a 7a   	db	04ah,05ah,06ah,07ah,00ah,01ah,02ah,03ah
   28dc   0a 1a 2a 3a   
   28e0   fd ed dd cd   	db	0fdh,0edh,0ddh,0cdh,0bdh,0adh,09dh,08dh
   28e4   bd ad 9d 8d   
   28e8   7c 6c 5c 4c   	db	07ch,06ch,05ch,04ch,03ch,02ch,01ch,00ch
   28ec   3c 2c 1c 0c   
   28f0   ef ff cf df   	db	0efh,0ffh,0cfh,0dfh,0afh,0bfh,08fh,09fh
   28f4   af bf 8f 9f   
   28f8   6e 7e 4e 5e   	db	06eh,07eh,04eh,05eh,02eh,03eh,00eh,01eh
   28fc   2e 3e 0e 1e   
                        ;
                        endrom	equ	$
                        ;
                        Dta:		ds	512
                        uint32_buf:	ds	UINT32_DIGITS+1	
                        		ds	128
                        localStack:	ds	1
                        saveStack:	ds	2
                        
                        dirbuf:	ds	512
                        ;
                        year:	ds	1
                        month:	ds	1
                        dom:	ds	1
                        hours:	ds	1
                        minutes: ds	1
                        seconds: ds	1
                        ;
                        epoch:	ds	4
                        ;
                        blkNum:		ds	1		; current block #
                        blkMode:	ds	1		; 0=checksum, 1=CRC
                        fileSize:	ds	4		; # bytes remaining in file
                        block0:		ds	128		; buffer for tx/rx
                        blockBuffer:
                        ;
                        	end
0006  ack           2544  AckedAction    266d  add32bits     20ee  B0loop1   
213c  B0opened      0004  b_devBBSER    0002  b_devFLPY     0001  b_devIDE  
0020  b_devNVR      0010  b_devRTC      0008  b_devUART     ff00  BIOS      
22ca  bitLoop       2d99  blkMode       2d98  blkNum        2d9e  block0    
23cf  BlockACKed    2e1e  blockBuffer    0008  bs            240b  bsLoop    
2006  Build         0018  can           23f7  Cancel        23fe  cancelLoop
000d  cr            0043  crc           2310  CrcMode       2800  crcTableHigh
2700  crcTableLow    25a8  crlf          0000  debug         259e  delay     
25a2  delay1        259d  delayX        2443  DidntGetACK    2b8e  dirbuf    
2044  dirofs        2500  DoLastChar    2d90  dom           228d  domDone   
2286  domLoop       2900  Dta           f800  EBIOS         2900  endrom    
0004  eot           2d94  epoch         0005  errdirnotempty    0001  errexists 
0003  errinvdir     0004  errisdir      0002  errnoffnd     0006  errnotexec
20d1  Exit          f830  f_astodt      f833  f_astotm      ff5d  f_atoi    
ff00  f_boot        ff42  f_bootide     f800  f_bread       ff6c  f_brktest 
f806  f_btest       f803  f_btype       ff33  f_div16       ff2a  f_drive   
f827  f_dttoas      ff6f  f_findtkn     ff57  f_freemem     ff81  f_getdev  
f815  f_gettod      ff45  f_hexin       ff48  f_hexout2     ff4b  f_hexout4 
f824  f_ideid       ff3c  f_ideread     ff36  f_idereset    f821  f_idesize 
ff39  f_idewrite    ff7b  f_idnum       ff3f  f_initcall    ff66  f_inmsg   
ff0f  f_input       ff69  f_inputl      ff63  f_intout      ff78  f_isalnum 
ff72  f_isalpha     ff75  f_ishex       ff5a  f_isnum       ff7e  f_isterm  
ff15  f_ltrim       ff1b  f_memcpy      ff54  f_minimon     ff51  f_mover   
ff09  f_msg         ff30  f_mul16       f836  f_nvrcchk     f81b  f_rdnvr   
ff21  f_rdsec       ff06  f_read        f82d  f_rtctest     ff27  f_seek    
ff24  f_seek0       ff2d  f_setbd       f818  f_settod      ff12  f_strcmp  
ff18  f_strcpy      f82a  f_tmtoas      ff4e  f_tty         ff03  f_type    
ff0c  f_typex       ff60  f_uintout     f80c  f_uread       f812  f_usetbd  
f80f  f_utest       f809  f_utype       fff9  f_version     f81e  f_wrnvr   
ff1e  f_wrtsec      2037  FilDes        23d2  FileDone      234a  FileSendLoop
2d9a  fileSize      2429  GetACK        243f  GotACK        2427  GotNAKorCRC
2d91  hours         22a4  hoursDone     229d  hoursLoop     03f6  I_SERVE   
25c5  itoa1         2642  itoa2         2646  itoa3         0406  K_BDAY    
0405  K_BMONTH      0403  K_BUILD       0407  K_BYEAR       0470  K_CLKFREQ 
0476  K_DAY         0468  K_HEAP        0442  K_HIMEM       0478  K_HOUR    
0465  K_LOWMEM      0479  K_MINUTE      0475  K_MONTH       0467  K_RETVAL  
047b  K_SECDEN      047d  K_SECNUM      047a  K_SECOND      0400  K_VER     
0477  K_YEAR        000a  lf            2000  LoadAdr       2b8b  localStack
2639  loop1         2d92  minutes       22b7  minutesDone    22af  minutesLoop
2d8f  month         202b  monthDays     2267  monthLoop     2280  monthsDone
2265  monthsLoop    2372  MoreToGo      0015  nak           2364  NearingTheEnd
2581  nextBlock     2092  NextFile      20c8  NextFileName    227a  noLeapYearChk
227a  notFebruary    2241  notLeapYear    036c  O_ALLOC       0004  O_APPND   
035a  O_BOOT        0366  O_BRKTEST     0324  O_CHDIR       0300  O_CLDBOOT 
0312  O_CLOSE       0001  O_CREAT       0475  O_DATTIM      036f  O_DEALLOC 
0318  O_DELETE      0369  O_DEVCTRL     031e  O_EXEC        0342  O_EXECBIN 
034e  O_GETDEV      0351  O_GETTOD      0363  O_INITCALL    034b  O_INMSG   
0339  O_INPUT       0357  O_INPUTL      0348  O_KINIT       0375  O_MEMCTRL 
0321  O_MKDIR       0333  O_MSG         0306  O_OPEN        0315  O_OPENDIR 
033f  O_PRINT       033c  O_PRTSTAT     032a  O_RDLUMP      0309  O_READ    
0336  O_READKEY     031b  O_RENAME      0327  O_RMDIR       030f  O_SEEK    
0360  O_SETBD       0345  O_SETDEF      0354  O_SETTOD      0372  O_TERMCTRL
0002  O_TRUNC       0330  O_TYPE        030c  O_WRITE       032d  O_WRLUMP  
0303  O_WRMBOOT     0000  r0            0001  r1            000a  r10       
000b  r11           000c  r12           000d  r13           000e  r14       
000f  r15           0002  r2            0003  r3            0004  r4        
0005  r5            0006  r6            0007  r7            0008  r8        
0009  r9            000a  ra            000b  rb            000c  rc        
000d  rd            000e  re            238d  ReadBytes     2523  readne    
255c  readne2       2577  recvne2dn     2569  recvne2lp     259b  recvne2lp0
256f  recvne2lp1    253e  recvnedn      2530  recvnelp      2599  recvnelp0 
2536  recvnelp1     2456  ResendBlock    000f  rf            2312  SaveMode  
2b8c  saveStack     0004  scall         2d93  seconds       2040  sector    
2471  Send128       2460  SendBlock     254e  SendBlockError    2447  SendEOT   
20e5  SendFile      2304  SendFileError    2473  SendStart     24bb  SendWithChecksum
249c  SendWithCRC    0001  soh           0005  sret          204a  start     
0002  stx           25cc  tobcdlp1      25dd  tobcdlp2      25e4  tobcdlp3  
25ed  tobcdlp3a     2610  tobcdlp4      ff4e  TTYout        2516  typect    
250e  typelp        2513  typenb        0020  UINT32_BITS    2b00  uint32_buf
000a  UINT32_DIGITS    25af  uint32_out    2663  uint32outz    036a  V_DVEC    
03fd  V_IVEC        241b  WaitNAKorCRC    2d8e  year          221b  yearLoop  
2249  yearsDone     23e6  ZeroBlock0    23ec  ZeroLoop      
